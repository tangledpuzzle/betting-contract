{
  "language": "Solidity",
  "sources": {
    "@api3/airnode-protocol/contracts/rrp/interfaces/IAirnodeRrpV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAuthorizationUtilsV0.sol\";\nimport \"./ITemplateUtilsV0.sol\";\nimport \"./IWithdrawalUtilsV0.sol\";\n\ninterface IAirnodeRrpV0 is\n    IAuthorizationUtilsV0,\n    ITemplateUtilsV0,\n    IWithdrawalUtilsV0\n{\n    event SetSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool sponsorshipStatus\n    );\n\n    event MadeTemplateRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event MadeFullRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        bytes data\n    );\n\n    event FailedRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        string errorMessage\n    );\n\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external;\n\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        string calldata errorMessage\n    ) external;\n\n    function sponsorToRequesterToSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool sponsorshipStatus);\n\n    function requesterToRequestCountPlusOne(address requester)\n        external\n        view\n        returns (uint256 requestCountPlusOne);\n\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        returns (bool isAwaitingFulfillment);\n}\n"
    },
    "@api3/airnode-protocol/contracts/rrp/interfaces/IAuthorizationUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAuthorizationUtilsV0 {\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view returns (bool[] memory statuses);\n}\n"
    },
    "@api3/airnode-protocol/contracts/rrp/interfaces/ITemplateUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITemplateUtilsV0 {\n    event CreatedTemplate(\n        bytes32 indexed templateId,\n        address airnode,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external returns (bytes32 templateId);\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        );\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (\n            address airnode,\n            bytes32 endpointId,\n            bytes memory parameters\n        );\n}\n"
    },
    "@api3/airnode-protocol/contracts/rrp/interfaces/IWithdrawalUtilsV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWithdrawalUtilsV0 {\n    event RequestedWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable;\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256 withdrawalRequestCount);\n}\n"
    },
    "@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAirnodeRrpV0.sol\";\n\n/// @title The contract to be inherited to make Airnode RRP requests\ncontract RrpRequesterV0 {\n    IAirnodeRrpV0 public immutable airnodeRrp;\n\n    /// @dev Reverts if the caller is not the Airnode RRP contract.\n    /// Use it as a modifier for fulfill and error callback methods, but also\n    /// check `requestId`.\n    modifier onlyAirnodeRrp() {\n        require(msg.sender == address(airnodeRrp), \"Caller not Airnode RRP\");\n        _;\n    }\n\n    /// @dev Airnode RRP address is set at deployment and is immutable.\n    /// RrpRequester is made its own sponsor by default. RrpRequester can also\n    /// be sponsored by others and use these sponsorships while making\n    /// requests, i.e., using this default sponsorship is optional.\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(address _airnodeRrp) {\n        airnodeRrp = IAirnodeRrpV0(_airnodeRrp);\n        IAirnodeRrpV0(_airnodeRrp).setSponsorshipStatus(address(this), true);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../util/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) { // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _path;\n        emit SetTrustedRemote(_srcChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0, \"LzApp: invalid minGas\");\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../util/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/IOFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface IOFTCore is IERC165 {\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/OFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../lzApp/NonblockingLzApp.sol\";\nimport \"./IOFTCore.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\n    using BytesLib for bytes;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint16 public constant PT_SEND = 0;\n\n    bool public useCustomAdapterParams;\n\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = abi.encode(PT_SEND, _toAddress, _amount);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) public virtual onlyOwner {\n        useCustomAdapterParams = _useCustomAdapterParams;\n        emit SetUseCustomAdapterParams(_useCustomAdapterParams);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        uint16 packetType;\n        assembly {\n            packetType := mload(add(_payload, 32))\n        }\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert(\"OFTCore: unknown packet type\");\n        }\n    }\n\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\n        _checkAdapterParams(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        uint amount = _debitFrom(_from, _dstChainId, _toAddress, _amount);\n\n        bytes memory lzPayload = abi.encode(PT_SEND, _toAddress, amount);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(uint16 _srcChainId, bytes memory, uint64, bytes memory _payload) internal virtual {\n        (, bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (uint16, bytes, uint));\n\n        address to = toAddressBytes.toAddress(0);\n\n        amount = _creditTo(_srcChainId, to, amount);\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _checkAdapterParams(uint16 _dstChainId, uint16 _pkType, bytes memory _adapterParams, uint _extraGas) internal virtual {\n        if (useCustomAdapterParams) {\n            _checkGasLimit(_dstChainId, _pkType, _adapterParams, _extraGas);\n        } else {\n            require(_adapterParams.length == 0, \"OFTCore: _adapterParams must be empty.\");\n        }\n    }\n\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual returns(uint);\n\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual returns(uint);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n        // Store the length of the first bytes array at the beginning of\n        // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n        // Maintain a memory counter for the current write location in the\n        // temp bytes array by adding the 32 bytes for the array length to\n        // the starting location.\n            let mc := add(tempBytes, 0x20)\n        // Stop copying when the memory counter reaches the length of the\n        // first bytes array.\n            let end := add(mc, length)\n\n            for {\n            // Initialize a copy counter to the start of the _preBytes data,\n            // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n            // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n            // Write the _preBytes data into the tempBytes memory 32 bytes\n            // at a time.\n                mstore(mc, mload(cc))\n            }\n\n        // Add the length of _postBytes to the current length of tempBytes\n        // and store it as the new length in the first 32 bytes of the\n        // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n        // Move the memory counter back from a multiple of 0x20 to the\n        // actual end of the _preBytes data.\n            mc := end\n        // Stop copying when the memory counter reaches the new combined\n        // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n        // Update the free-memory pointer by padding our last write location\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n        // next 32 byte block, then round down to the nearest multiple of\n        // 32. If the sum of the length of the two arrays is zero then add\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n            not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n        // Read the first 32 bytes of _preBytes storage, which is the length\n        // of the array. (We don't need to use the offset into the slot\n        // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n        // Arrays of 31 bytes or less have an even value in their slot,\n        // while longer arrays have an odd value. The actual length is\n        // the slot divided by two for odd values, and the lowest order\n        // byte divided by two for even values.\n        // If the slot is even, bitwise and the slot with 255 and divide by\n        // two to get the length. If the slot is odd, bitwise and the slot\n        // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n            // Since the new array still fits in the slot, we just need to\n            // update the contents of the slot.\n            // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                _preBytes.slot,\n                // all the modifications to the slot are inside this\n                // next block\n                add(\n                // we can just add to the slot contents because the\n                // bytes we want to change are the LSBs\n                fslot,\n                add(\n                mul(\n                div(\n                // load the bytes from memory\n                mload(add(_postBytes, 0x20)),\n                // zero all bytes to the right\n                exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n                ),\n                // increase length by the double of the memory\n                // bytes length\n                mul(mlength, 2)\n                )\n                )\n                )\n            }\n            case 1 {\n            // The stored value fits in the slot, but the combined value\n            // will exceed it.\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // The contents of the _postBytes array start 32 bytes into\n            // the structure. Our first read should obtain the `submod`\n            // bytes that can fit into the unused space in the last word\n            // of the stored array. To get this, we read 32 bytes starting\n            // from `submod`, so the data we read overlaps with the array\n            // contents by `submod` bytes. Masking the lowest-order\n            // `submod` bytes allows us to add that value directly to the\n            // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                sc,\n                add(\n                and(\n                fslot,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                ),\n                and(mload(mc), mask)\n                )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n            // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n            // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n            // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n            // Copy over the first `submod` bytes of the new data as in\n            // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n    internal\n    view\n    returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n        // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n        // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                    // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                        // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                        let cb := 1\n\n                    // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                            // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/util/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n            _gas, // gas\n            _target, // recipient\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n    internal\n    pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n        // load the first word of\n            let _word := mload(add(_buf, 0x20))\n        // mask out the top 4 bytes\n        // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/baseGames/singleplayer/BaseSPGame.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../interfaces/IFareToken.sol\";\n\nimport \"../../libraries/BetHelpers.sol\";\nimport \"../../requesters/BaseRequester.sol\";\n\nabstract contract BaseSPGame is BaseRequester, Ownable {\n  using BetHelpers for BetHelpers.Bet;\n  IFareToken internal fareToken;\n\n  address public rewardsAddress;\n  uint public multiplier = 1 ether; // x1.0000\n  uint public houseEdge = 0.01 ether; // 1.00%\n  uint public rewardsMintPercentage = 0.005 ether; // 0.5%\n  uint constant MINT_CAP_PERCENTAGE = 0.005 ether; // 0.5%\n  uint public blockNumberCountForRefund = 200; // TODO: Maybe we should add some kind of lowest cap for this\n\n  mapping(bytes32 => address) public requestIdToAddress;\n  mapping(address => BetHelpers.Bet) public addressToBet;\n\n  event BetPlaced(bytes32 indexed requestId, address indexed player);\n  event BetResolved(bytes32 indexed requestId, address indexed player);\n  event BetRefund(bytes32 indexed requestId, address indexed player);\n\n  constructor(address _fareTokenAddress, address _rewardsAddress) {\n    require(\n      _fareTokenAddress != address(0),\n      \"Not a valid address for _fareTokenAddress\"\n    );\n    require(\n      _rewardsAddress != address(0),\n      \"Not a valid address for _rewardsAddress\"\n    );\n    fareToken = IFareToken(_fareTokenAddress);\n    rewardsAddress = _rewardsAddress;\n  }\n\n  function getFareTokenAddress() public view returns (address fareAddress) {\n    fareAddress = address(fareToken);\n  }\n\n  // It would be better if it was public, than ecosystem developers can create another function that would call this\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable virtual;\n\n  function refundBet() public virtual;\n\n  // Given randomNumber, what would be the houseSide (or result)\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view virtual returns (uint);\n\n  // Given betSide and houseSide return outcome (outcome could represent if they won or lost.)\n  // It could also represent which type of bet is won. For example for roulette, bet on red's outcome and bet on green's outcome could be different\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view virtual returns (uint);\n\n  // Given outcome and betSide calculate the multiplier so that payout will be calculated correctly\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view virtual returns (uint);\n\n  function _placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) internal {\n    uint totalAmount = amount * count;\n    require(addressToBet[msg.sender].blockNumber == 0, \"Bet still in progress\");\n    require(totalAmount != 0, \"Can not bet 0 token\");\n    require(count <= 100, \"Max bet count is 100\");\n\n    bytes32 requestId = requestRandomNumbers(count);\n    requestIdToAddress[requestId] = msg.sender;\n    addressToBet[msg.sender] = BetHelpers.Bet({\n      requestId: requestId,\n      side: side,\n      amount: amount,\n      stopLoss: stopLoss,\n      stopGain: stopGain,\n      blockNumber: uint64(block.number),\n      count: count\n    });\n    fareToken.burnFare(msg.sender, totalAmount);\n    emit BetPlaced(requestId, msg.sender);\n  }\n\n  function _resolveBet(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal {\n    address player = requestIdToAddress[requestId];\n    require(player != address(0), \"RequestId corresponds to zeroAddress\");\n    BetHelpers.Bet memory bet = addressToBet[player];\n\n    uint len = randomNumbers.length;\n    uint grossPayout;\n    uint i;\n    for (i = 0; i < len; i++) {\n      uint currentlySpentAmount = bet.calculateCurrentlySpentAmount(i + 1);\n      uint houseSide = gameSpecificGetHouseSide(randomNumbers[i], bet.side);\n      uint outcome = gameSpecificGetOutcome(houseSide, bet.side);\n      uint betMultiplier = gameSpecificGetMultiplier(outcome, bet.side);\n\n      if (betMultiplier > 0) {\n        uint payoutAmount = bet.calculatePayout(betMultiplier, houseEdge);\n        grossPayout += payoutAmount;\n      }\n\n      bool isLimitsTriggered = bet.checkStopLimits(\n        grossPayout,\n        currentlySpentAmount\n      );\n      if (isLimitsTriggered) {\n        uint remainingBetCount = len - i - 1;\n        // Increase payout for unplayed bets because of the limit trigger\n        grossPayout += remainingBetCount * bet.amount;\n        // Increase i to correctly represent actually played bet count. This value will be used when minting for rewardsAddress\n        // Ex: when you hit it while i = 0. Actually played bet count would be 1\n        i++;\n        break;\n      }\n    }\n    delete requestIdToAddress[requestId];\n    delete addressToBet[player];\n\n    // Mint payout for the player\n    fareToken.mintFare(player, grossPayout);\n    // Mint for rewards address\n    fareToken.mintFare(\n      rewardsAddress,\n      bet.calculateRewardsPayout(i, rewardsMintPercentage)\n    );\n    emit BetResolved(requestId, player);\n  }\n\n  function _refundBet() internal {\n    BetHelpers.Bet memory bet = addressToBet[msg.sender];\n    require(bet.blockNumber != 0, \"Bet already resolved or never played\");\n    require(\n      block.number > bet.blockNumber + blockNumberCountForRefund,\n      \"Too early to get a refund\"\n    );\n\n    delete requestIdToAddress[bet.requestId];\n    delete addressToBet[msg.sender];\n\n    // Mint payout for the player\n    fareToken.mintFare(msg.sender, bet.amount * bet.count);\n    emit BetRefund(bet.requestId, msg.sender);\n  }\n\n  function setMultiplier(uint newMultiplier) public onlyOwner {\n    multiplier = newMultiplier;\n  }\n\n  function setHouseEdge(uint newHouseEdge) public onlyOwner {\n    houseEdge = newHouseEdge;\n  }\n\n  function setFareToken(address _fareToken) external onlyOwner {\n    require(_fareToken != address(0), \"_fareToken is invalid\");\n    fareToken = IFareToken(_fareToken);\n  }\n\n  function setRewardsAddress(address _rewardsAddress) public onlyOwner {\n    require(_rewardsAddress != address(0), \"_rewardsAddress is invalid\");\n    rewardsAddress = _rewardsAddress;\n  }\n\n  function setRewardsMintPercentage(\n    uint _rewardsMintPercentage\n  ) public onlyOwner {\n    require(\n      _rewardsMintPercentage <= MINT_CAP_PERCENTAGE,\n      \"_rewardsMintPercentage should be lte mintCapPercentage\"\n    );\n    rewardsMintPercentage = _rewardsMintPercentage;\n  }\n\n  function setBlockNumberCountForRefund(\n    uint _blockNumberCountForRefund\n  ) public onlyOwner {\n    blockNumberCountForRefund = _blockNumberCountForRefund;\n  }\n}\n"
    },
    "contracts/FareBomb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareBomb is BaseSPGame, VRFRequester {\n  // NOTE: Possible optimization => rather than mapping(uint => mapping(uint => uint))\n  // NOTE: Maybe using mapping(uint => uint) would be more efficient. I could encode both bombCount and revealCount into single uint16\n  // NOTE: Turns out => nested mapping version AVG fulfill function gasUsage: 183184\n  // NOTE: Turns out => single mapping version AVG fulfill function gasUsage: 183331\n  mapping(uint => mapping(uint => uint))\n    private bombCountToRevealCountToMultiplier;\n\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {\n    // Initialize the multipliers for specific bombCounts and revealCounts\n    // So that you do not have to recompute them again and again, you would just access a state variable\n    for (uint bombCount = 0; bombCount < 25; bombCount++) {\n      // For each bombCount\n      for (uint revealCount = 0; revealCount < 25; revealCount++) {\n        if (bombCount + revealCount > 25) continue;\n        // For each revealCount\n        uint aggregateMultiplier = multiplier;\n        for (uint i = 0; i < revealCount; i++) {\n          // We are calculating the specific multiplier for given bombCount and getRevealCount\n          // We have to use a for loop based on revealCount\n          aggregateMultiplier = BetHelpers.mulDiv(\n            aggregateMultiplier,\n            BetHelpers.mulDiv(\n              (25 - i) * 10 ** 18,\n              1 ether,\n              (25 - i - bombCount) * 10 ** 18\n            ),\n            1 ether\n          );\n        }\n\n        bombCountToRevealCountToMultiplier[bombCount][\n          revealCount\n        ] = aggregateMultiplier;\n      }\n    }\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal virtual override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public virtual override {\n    _refundBet();\n  }\n\n  // Allows you to get a bit's value\n  // If _boolNumber is 0, then we will get the rightmost bit\n  // Therefore, when you increase the boolNumber, you will get the bit on the left\n  // NOTE: GAS USAGE 910 gas\n  function getBoolean(\n    uint256 _packedBools,\n    uint256 _boolNumber\n  ) private pure returns (bool) {\n    uint256 flag = (_packedBools >> _boolNumber) & uint256(1);\n    return (flag == 1 ? true : false);\n  }\n\n  // Allows you to set a bit's value\n  // If _boolNumber is 0, then we will get the rightmost bit\n  // Therefore, when you increase the boolNumber, you will get the bit on the left\n  // NOTE: GAS USAGE 1049\n  function setBoolean(\n    uint256 _packedBools,\n    uint256 _boolNumber,\n    bool _value\n  ) private pure returns (uint256) {\n    if (_value) {\n      _packedBools = _packedBools | (uint256(1) << _boolNumber);\n      return _packedBools;\n    } else {\n      _packedBools = _packedBools & ~(uint256(1) << _boolNumber);\n      return _packedBools;\n    }\n  }\n\n  // Allows you to encode uint8 bombCount, uint8 revealCount and uint32 revealArray as a uint256\n  // [208 bit: empty, 8 bit: bombCount; 8 bit: revealCount, 32 bit: revealArray]\n  // NOTE: What if we encode `encodeSide` as uint8 bombCount, bool[25] revealArray\n  // NOTE: I have tested it, looks like it was even worse. Becuase I cannot just cast bool[] to uint256 and use. I had to iterate the array and convert it manually. Which costs more gas\n  // NOTE: GAS USAGE 1433\n  function encodeSide(\n    uint8 bombCount,\n    uint8 revealCount,\n    uint32 revealArray\n  ) private pure returns (uint side) {\n    side =\n      (uint(bombCount) << 40) +\n      (uint(revealCount) << 32) +\n      uint(revealArray);\n  }\n\n  // Allows you to decode a uint256 side as uint8 bombCount, uint8 revealCount, uint32 revealArray\n  // NOTE: GAS USAGE 999\n  function decodeSide(\n    uint side\n  )\n    private\n    pure\n    returns (uint8 bombCount, uint8 revealCount, uint32 revealArray)\n  {\n    bombCount = uint8(side >> 40);\n    revealCount = uint8(side >> 32);\n    revealArray = uint32(side);\n  }\n\n  // Given revealArray from user, returns how many positions user wants to reveal\n  // It does it by iteration rightmost 25 bits and counting true bits\n  // NOTE: 8762 gas\n  function getRevealCount(\n    uint32 revealArray\n  ) private pure returns (uint8 revealCount) {\n    revealCount = 0;\n    for (uint i = 0; i < 25; i++) {\n      if (getBoolean(revealArray, i)) {\n        revealCount++;\n      }\n    }\n  }\n\n  // This function is only for the usage of frontend.\n  // If user wants to reveal positions [2, 24], this function would return the corresponding uint32 to represent it correctly\n  // In the case of [2, 24], it would be something like 0010 000 0000 0000 0000 0000 0100 = 16777220\n  // We are not doing this process inside the `encodeSideAndPlaceBet` to save gas\n  function encodeRevealArray(\n    uint[] calldata revealArray\n  ) external pure returns (uint32) {\n    uint len = revealArray.length;\n    uint encodedRevealArray = 0;\n    for (uint i = 0; i < len; i++) {\n      encodedRevealArray = setBoolean(encodedRevealArray, revealArray[i], true);\n    }\n    return uint32(encodedRevealArray);\n  }\n\n  // Handles side encoding and input requirements for placeBet\n  // NOTE: GAS USAGE average 253094\n  function encodeSideAndPlaceBet(\n    uint8 bombCount,\n    uint32 encodedRevealArray,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) external payable {\n    // For FareBomb, user will indicate how many bombs they are playing the game with and the indexes that they want to reveal.\n    // To represent that values. We will use uint256 and we will think it as bit[]\n    // So, it will be a bit[256]\n    // We will store: bombCount, revealCount and revealArray inside those 256 bits\n    // We will store bombCount in uint8, revealCount in uint8, revealArray in uint32\n    // Lets not use this one => (Right padding) Example: If you want to reveal 0th and 2nd indexes => [101000000...]\n    // Lets use this one => (Left padding) Example: If you want to reveal 0th and 2nd indexes => [...000000000101] => You would give \"5\", 0b101, 0x05\n    // Inside the revealArray, if ith (from right) bit is 1 then it means, user is trying to reveal that position (i)\n    require(bombCount > 0 && bombCount < 25, \"0<bombCount<25\");\n    // For the map, we are using 25 bits, therefore revealArray should not be larger than 2**25. Because, with 25 bits we can represent at most 2**25 - 1\n    require(\n      encodedRevealArray > 0 && encodedRevealArray < 2 ** 25,\n      \"0<revealArray<2**25\"\n    );\n    uint8 revealCount = getRevealCount(encodedRevealArray);\n    require(revealCount + bombCount <= 25, \"revealCount + bombCount <= 25\");\n    placeBet(\n      encodeSide(bombCount, revealCount, encodedRevealArray),\n      amount,\n      stopLoss,\n      stopGain,\n      count\n    );\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable virtual override {\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function getNewBombIndex(\n    uint8 startingIndex,\n    uint32 currentMap,\n    uint8 stepCount\n  ) private pure returns (uint8) {\n    uint i;\n    // Iterate stepCount amount\n    for (i = 0; i < stepCount; i++) {\n      // Check if it is a bomb\n      bool isBomb = getBoolean(currentMap, (startingIndex + i) % 25);\n      if (isBomb) {\n        // If it is a bomb, increase the stepCount so that, we would have an extra iteration for each bomb we have seen\n        // Which could also be understood as, skipping the bombs or not incremeting our count if it was a bomb\n        stepCount++;\n      }\n    }\n    return uint8((startingIndex + i) % 25);\n  }\n\n  // We must have bombCount amount of randomNumbers to represent each bomb\n  // Since we need to have randomNumbers from 0 to 25, randomNumber would represent the bomb index\n  // NOTE: randomNumber will not directly represent bombIndex, because in that case, we might get the same randomNumber therefore try to put 2 bombs to the same place.\n  // NOTE: Since we dont want to put 2 bombs to a same place, we can try to handle it by adding 1 till we find a new empty place.\n  // NOTE: But the upper approach would create a case where positions that are adjacent to the bomb would have a higher chance to get a new bomb\n  // NOTE: Since, we want each position to have the same probability to contain a bomb, we will do something different\n  // NOTE: What we will do is, with first randomNumber we will put a bomb there, and we will have a `currentIndex` just after the bomb\n  // NOTE: With the second randomNumber, we will start from our `currentIndex` and add secondRandomNumber amount positions. Put a bomb there and update `currentIndex` just after the bomb\n  // NOTE: During iterating, if we encounter a bomb, we will increase our iteration count. With this update, we will never put a second bomb to the same place and each position will have the same probability\n  // We should be able to create up to 24 randomNumbers (0 < randomNumber < 24) from a single randomNumber provided from VRF which is a uint256 randomNumber\n  // VRF returns us a uint256 randomNumber, we will take (mod 25) to find a unique randomNumber and update the original randomNumber by dividing it by 100. Therefore, each randomNumber will be independent\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    // Given uint256 randomNumber. Based on the bombCount, inside the betSide, create bombArray\n    (uint8 bombCount, , ) = decodeSide(betSide);\n    uint32 bombArray = 0;\n    uint8 currentIndex = 0;\n    for (uint8 i = 0; i < bombCount; i++) {\n      // Create new randomNumbers on each iteration from a single randomNumber\n      // NOTE: What I had in mind was to get the (mod 100) for the random number to access the last 2 digits of the random number\n      // NOTE: Since those 2 digits can represent 0-99 and each number has the same probability, I can just take (mod 25) and numbers from 0-24 would have the same probability\n      // NOTE: And then with those 2 digits, I would take (mod 25) to get randomNumber between 0-24\n      // NOTE: Since, I am taking a (mod 25) at the end I dont have to take (mod 100) beforehand\n      // NOTE: Because, everything before the last 2 digits is divisable by 100, and therefore divisable by 25\n      // NOTE: So, I am only taking a (mod 25) and then dividing the original randomNumber by 100 to have new last 2 digits on each iteration\n      // Get randomNumber based on last 2 digits\n      uint8 currentRandomNumber = uint8(randomNumber % 25);\n      // Update the original randomNumber to have new randomNumber on each iteration\n      randomNumber = randomNumber / 100;\n      // Get index for the new bomb\n      uint8 newBombIndex = getNewBombIndex(\n        currentIndex,\n        bombArray,\n        currentRandomNumber\n      );\n\n      // Set specific bit to true to represent that there is a bomb\n      bombArray = uint32(setBoolean(bombArray, newBombIndex, true));\n      // Set the currentIndex to be the next index after bomb\n      currentIndex = (newBombIndex + 1) % 25;\n    }\n    return bombArray;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    (, , uint32 revealArray) = decodeSide(betSide);\n    (, , uint32 bombArray) = decodeSide(houseSide);\n    bool hit = false;\n    for (uint i = 0; i < 25; i++) {\n      if (getBoolean(revealArray, i) && getBoolean(bombArray, i)) {\n        hit = true;\n        break;\n      }\n    }\n    return hit ? 0 : betSide;\n  }\n\n  // NOTE: Not sure, but check if it would be more optimized if we stored the probabilies (or multipliers) rather than calculating from scratch everytime\n  // NOTE: It is, if we retrieve a value from a mapping(uint => mapping(uint => uint)), this function would cost 3282 gas\n  // NOTE: With iterating and calculating probability it would cost => 7277 gas for 4 revealCount, 2594 gas for 1 revealCount, 4155 gas for 2 revealCount\n  // NOTE: Initialize the values inside the constructor\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    if (outcome == 0) return 0;\n    (uint8 bombCount, uint8 revealCount, ) = decodeSide(betSide);\n    // uint aggregateMultiplier = 1 ether;\n    // /**\n    //  * (25 - i) / (25 - i - bombCount)\n    //  * where i represents the iteration count. i will start from 0 and go till revealCount (inclusive)\n    //  * Example => revealCount = 3, bombCount = 2\n    //  *         => (25 / 23) * (24 / 22) * (23 / 21)\n    //  */\n    // for (uint i = 0; i < revealCount; i++) {\n    //   aggregateMultiplier = BetHelpers.mulDiv(\n    //     aggregateMultiplier,\n    //     BetHelpers.mulDiv(\n    //       (25 - i) * 10 ** 18,\n    //       1 ether,\n    //       (25 - i - bombCount) * 10 ** 18\n    //     ),\n    //     1 ether\n    //   );\n    // }\n    // return aggregateMultiplier;\n    return bombCountToRevealCountToMultiplier[bombCount][revealCount];\n  }\n}\n"
    },
    "contracts/FareBombBit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"hardhat/console.sol\";\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareBombBit is BaseSPGame, VRFRequester {\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {}\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal virtual override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public virtual override {\n    _refundBet();\n  }\n\n  // Allows you to get a bit's value\n  // If _boolNumber is 0, then we will get the rightmost bit\n  // Therefore, when you increase the boolNumber, you will get the bit on the left\n  // NOTE: GAS USAGE 910 gas\n  function getBoolean(\n    uint256 _packedBools,\n    uint256 _boolNumber\n  ) public pure returns (bool) {\n    uint256 flag = (_packedBools >> _boolNumber) & uint256(1);\n    return (flag == 1 ? true : false);\n  }\n\n  // Allows you to set a bit's value\n  // If _boolNumber is 0, then we will get the rightmost bit\n  // Therefore, when you increase the boolNumber, you will get the bit on the left\n  // NOTE: GAS USAGE 1049\n  function setBoolean(\n    uint256 _packedBools,\n    uint256 _boolNumber,\n    bool _value\n  ) public pure returns (uint256) {\n    if (_value) {\n      _packedBools = _packedBools | (uint256(1) << _boolNumber);\n      return _packedBools;\n    } else {\n      _packedBools = _packedBools & ~(uint256(1) << _boolNumber);\n      return _packedBools;\n    }\n  }\n\n  // Allows you to encode uint8 bombCount, uint8 revealCount and uint32 revealArray as a uint256\n  // [208 bit: empty, 8 bit: bombCount; 8 bit: revealCount, 32 bit: revealArray]\n  // TODO: What if we encode `encodeSide` as uint8 bombCount, bool[25] revealArray\n  // NOTE: GAS USAGE 1433\n  function encodeSide(\n    uint8 bombCount,\n    uint8 revealCount,\n    uint32 revealArray\n  ) public pure returns (uint side) {\n    side =\n      (uint(bombCount) << 40) +\n      (uint(revealCount) << 32) +\n      uint(revealArray);\n  }\n\n  // NOTE: GAS USAGE 1071\n  function encodeSideAlt(\n    uint8 bombCount,\n    uint32 revealArray\n  ) public pure returns (uint side) {\n    side = (uint(bombCount) << 32) + uint(revealArray);\n  }\n\n  // Allows you to decode a uint256 side as uint8 bombCount, uint8 revealCount, uint32 revealArray\n  // NOTE: GAS USAGE 999\n  function decodeSide(\n    uint side\n  )\n    public\n    pure\n    returns (uint8 bombCount, uint8 revealCount, uint32 revealArray)\n  {\n    bombCount = uint8(side >> 40);\n    revealCount = uint8(side >> 32);\n    revealArray = uint32(side);\n  }\n\n  // Allows you to decode a uint256 side as uint8 bombCount, uint8 revealCount, uint32 revealArray\n  // NOTE: GAS USAGE 780\n  function decodeSideAlt(\n    uint side\n  ) public pure returns (uint8 bombCount, uint32 revealArray) {\n    bombCount = uint8(side >> 32);\n    revealArray = uint32(side);\n  }\n\n  // Given revealArray from user, returns how many positions user wants to reveal\n  // It does it by iteration rightmost 25 bits and counting true bits\n  // NOTE: 8762 gas\n  function getRevealCount(\n    uint32 revealArray\n  ) public pure returns (uint8 revealCount) {\n    revealCount = 0;\n    for (uint i = 0; i < 25; i++) {\n      if (getBoolean(revealArray, i)) {\n        revealCount++;\n      }\n    }\n  }\n\n  // Handles side encoding and input requirements for placeBet\n  // NOTE: GAS USAGE average 248793\n  function prePlaceBet(\n    uint8 bombCount,\n    uint32 revealArray,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) external payable {\n    // For FareBomb, user will indicate how many bombs they are playing the game with and the indexes that they want to reveal.\n    // To represent that values. We will use uint256 and we will think it as bit[]\n    // So, it will be a bit[256]\n    // We will store: bombCount, revealCount and revealArray inside those 256 bits\n    // We will store bombCount in uint8, revealCount in uint8, revealArray in uint32\n    // Lets not use this one => (Right padding) Example: If you want to reveal 0th and 2nd indexes => [101000000...]\n    // Lets use this one => (Left padding) Example: If you want to reveal 0th and 2nd indexes => [...000000000101] => You would give \"5\", 0b101, 0x05\n    // Inside the revealArray, if ith (from right) bit is 1 then it means, user is trying to reveal that position (i)\n    require(bombCount < 25, \"Max bombCount: 24\");\n    // For the map, we are using 25 bits, therefore revealArray should not be larger than 2**25. Because, with 25 bits we can represent at most 2**25 - 1\n    require(revealArray < 2 ** 25, \"Invalid revealArray: Too high\");\n    uint8 revealCount = getRevealCount(revealArray);\n    require(\n      revealCount + bombCount <= 25,\n      \"Bomb count and revealed count should be max 25\"\n    );\n    placeBet(\n      encodeSide(bombCount, revealCount, revealArray),\n      amount,\n      stopLoss,\n      stopGain,\n      count\n    );\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable virtual override {\n    console.log(\"Encoded Side: %s\", side);\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function getNewBombIndex(\n    uint8 startingIndex,\n    uint32 currentMap,\n    uint8 stepCount\n  ) public pure returns (uint8) {\n    uint i;\n    // Iterate stepCount amount\n    for (i = 0; i < stepCount; i++) {\n      // Check if it is a bomb\n      bool isBomb = getBoolean(currentMap, (startingIndex + i) % 25);\n      if (isBomb) {\n        // If it is a bomb, increase the stepCount so that, we would have an extra iteration for each bomb we have seen\n        // Which could also be understood as, skipping the bombs or not incremeting our count if it was a bomb\n        stepCount++;\n      }\n    }\n    return uint8((startingIndex + i) % 25);\n  }\n\n  // We must have bombCount amount of randomNumbers to represent each bomb\n  // Since we need to have randomNumbers from 0 to 25, randomNumber would represent the bomb index, a randomNumber could be represented by a byte (0x00-0xff)\n  // NOTE: randomNumber will not directly represent bombIndex, because in that case, we might get the same randomNumber therefore try to put 2 bombs to the same place.\n  // NOTE: Since we dont want to put 2 bombs to a same place, we can try to handle it by adding 1 till we find a new empty place.\n  // NOTE: But the upper approach would create a case where positions that are adjacent to the bomb would have a higher chance to get a new bomb\n  // NOTE: Since, we want each position to have the same probability to contain a bomb, we will do something different\n  // NOTE: What we will do is, with first randomNumber we will put a bomb there, and we will have a `currentIndex` just after the bomb\n  // NOTE: With the second randomNumber, we will start from our `currentIndex` and add secondRandomNumber amount positions. Put a bomb there and update `currentIndex` just after the bomb\n  // NOTE: During iterating, if we encounter a bomb, we will increase our iteration count. With this update, we will never put a second bomb to the same place\n  // We should be able to create up to 24 randomNumbers (0 < randomNumber < 24) from a single randomNumber provided from VRF which is a uint256 randomNumber\n  // VRF returns us a 32 byte randomNumber, what we will do is, get each byte of the vrf randomNumber (starting from most significant byte, rightmost byte)\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    // Given uint256 randomNumber. Based on the bombCount, inside the betSide, create bombMap\n    (uint8 bombCount, , ) = decodeSide(betSide);\n    uint32 bombMap = 0;\n    uint8 currentIndex = 0;\n    for (uint8 i = 0; i < bombCount; i++) {\n      // Create new randomNumbers on each iteration from a single randomNumber\n      // NOTE: What I had in mind was to get the (mod 100) for the random number to access the last 2 digits of the random number\n      // NOTE: Since those 2 digits can represent 0-99 and each number has the same probability, I can just take (mod 25) and numbers from 0-24 would have the same probability\n      // NOTE: And then with those 2 digits, I would take (mod 25) to get randomNumber between 0-24\n      // NOTE: Since, I am taking a (mod 25) at the end I dont have to take (mod 100) beforehand\n      // NOTE: Because, everything before the last 2 digits is divisable by 100, and therefore divisable by 25\n      // NOTE: So, I am only taking a (mod 25) and then dividing the original randomNumber by 100 to have new last 2 digits on each iteration\n      // Get randomNumber based on last 2 digits\n      uint8 currentRandomNumber = uint8(randomNumber % 25);\n      // Update the original randomNumber to have new randomNumber on each iteration\n      randomNumber = randomNumber / 100;\n\n      // Get index for the new bomb\n      uint8 newBombIndex = getNewBombIndex(\n        currentIndex,\n        bombMap,\n        currentRandomNumber\n      );\n\n      // Set specific bit to true to represent that there is a bomb\n      bombMap = uint32(setBoolean(bombMap, newBombIndex, true));\n      // Set the currentIndex to be the next index after bomb\n      currentIndex = (newBombIndex + 1) % 25;\n    }\n    return bombMap;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    (, , uint32 revealArray) = decodeSide(betSide);\n    (, , uint32 bombMap) = decodeSide(houseSide);\n    bool hit = false;\n    for (uint i = 0; i < 25; i++) {\n      if (getBoolean(revealArray, i) && getBoolean(bombMap, i)) {\n        hit = true;\n        break;\n      }\n    }\n    return hit ? 0 : betSide;\n  }\n\n  // TODO: Not sure, but check if it would be more optimized if we stored the probabilies (or multipliers) rather than calculating from scratch everytime\n  // TODO: It is, if we retrieve a value from a mapping(uint => mapping(uint => uint)), this function would cost 3282 gas\n  // TODO: With iterating and calculating probability it would cost => 7277 gas for 4 revealCount, 2594 gas for 1 revealCount, 4155 gas for 2 revealCount\n  // TODO: Initialize the values inside the constructor\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    if (outcome == 0) return 0;\n    (uint8 bombCount, uint8 revealCount, ) = decodeSide(betSide);\n    uint aggregateMultiplier = 1 ether;\n    /**\n     * (25 - i) / (25 - i - bombCount)\n     * where i represents the iteration count. i will start from 0 and go till revealCount (inclusive)\n     * Example => revealCount = 3, bombCount = 2\n     *         => (25 / 23) * (24 / 22) * (23 / 21)\n     */\n    for (uint i = 0; i < revealCount; i++) {\n      aggregateMultiplier = BetHelpers.mulDiv(\n        aggregateMultiplier,\n        BetHelpers.mulDiv(\n          (25 - i) * 10 ** 18,\n          1 ether,\n          (25 - i - bombCount) * 10 ** 18\n        ),\n        1 ether\n      );\n    }\n\n    return aggregateMultiplier;\n  }\n\n  // This function is only for the usage of frontend.\n  // If user wants to reveal positions [2, 24], this function would return the corresponding uint32 to represent it correctly\n  // In the case of [2, 24], it would be something like 0010 000 0000 0000 0000 0000 0100 = 16777220\n  function createRevealArray(\n    uint[] calldata revealPositions\n  ) external pure returns (uint32) {\n    uint len = revealPositions.length;\n    uint revealArray = 0;\n    for (uint i = 0; i < len; i++) {\n      revealArray = setBoolean(revealArray, revealPositions[i], true);\n    }\n    return uint32(revealArray);\n  }\n}\n"
    },
    "contracts/FareBombByte.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"hardhat/console.sol\";\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareBombByte is BaseSPGame, VRFRequester {\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {}\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal virtual override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public virtual override {\n    _refundBet();\n  }\n\n  function boolArrayToUint256(\n    bool[25] memory arr\n  ) public pure returns (uint256) {\n    uint256 result = 0;\n    for (uint i = 0; i < 25; i++) {\n      if (arr[i]) {\n        result |= (1 << (8 * i));\n      }\n    }\n    return result;\n  }\n\n  // Allows you to encode uint8 bombCount, uint8 revealCount and uint32 revealArray as a uint256\n  // [208 bit: empty, 8 bit: bombCount; 8 bit: revealCount, 32 bit: revealArray]\n  // TODO: What if we encode `encodeSide` as uint8 bombCount, bool[25] revealArray\n  // NOTE: GAS USAGE 1433\n  function encodeSide(\n    uint8 bombCount,\n    uint8 revealCount,\n    bool[25] calldata revealArray\n  ) public pure returns (uint side) {\n    side =\n      (uint(bombCount) << 208) +\n      (uint(revealCount) << 200) +\n      boolArrayToUint256(revealArray);\n  }\n\n  function uint256ToBoolArray(\n    uint256 num\n  ) public pure returns (bool[25] memory) {\n    bool[25] memory arr;\n    for (uint i = 0; i < 25; i++) {\n      arr[i] = (num & (uint256(1) << (i * 8))) != 0;\n    }\n    return arr;\n  }\n\n  // Allows you to decode a uint256 side as uint8 bombCount, uint8 revealCount, uint32 revealArray\n  // NOTE: GAS USAGE 999\n  function decodeSide(\n    uint side\n  )\n    public\n    pure\n    returns (uint8 bombCount, uint8 revealCount, bool[25] memory revealArray)\n  {\n    bombCount = uint8(side >> 40);\n    revealCount = uint8(side >> 32);\n    revealArray = uint256ToBoolArray(side);\n  }\n\n  // Given revealArray from user, returns how many positions user wants to reveal\n  // It does it by iteration rightmost 25 bits and counting true bits\n  // NOTE: 8762 gas\n  function getRevealCount(\n    bool[25] calldata revealArray\n  ) public pure returns (uint8 revealCount) {\n    revealCount = 0;\n    for (uint i = 0; i < 25; i++) {\n      if (revealArray[i]) {\n        revealCount++;\n      }\n    }\n  }\n\n  // Handles side encoding and input requirements for placeBet\n  // NOTE: GAS USAGE average 248793\n  function prePlaceBet(\n    uint8 bombCount,\n    bool[25] calldata revealArray,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) external payable {\n    // For FareBomb, user will indicate how many bombs they are playing the game with and the indexes that they want to reveal.\n    // To represent that values. We will use uint256 and we will think it as bit[]\n    // So, it will be a bit[256]\n    // We will store: bombCount, revealCount and revealArray inside those 256 bits\n    // We will store bombCount in uint8, revealCount in uint8, revealArray in uint32\n    // Lets not use this one => (Right padding) Example: If you want to reveal 0th and 2nd indexes => [101000000...]\n    // Lets use this one => (Left padding) Example: If you want to reveal 0th and 2nd indexes => [...000000000101] => You would give \"5\", 0b101, 0x05\n    // Inside the revealArray, if ith (from right) bit is 1 then it means, user is trying to reveal that position (i)\n    require(bombCount < 25, \"Max bombCount: 24\");\n    // For the map, we are using 25 bits, therefore revealArray should not be larger than 2**25. Because, with 25 bits we can represent at most 2**25 - 1\n    // require(revealArray < 2 ** 25, \"Invalid revealArray: Too high\");\n    uint8 revealCount = getRevealCount(revealArray);\n    // require(\n    //   revealCount + bombCount <= 25,\n    //   \"Bomb count and revealed count should be max 25\"\n    // );\n    placeBet(\n      encodeSide(bombCount, revealCount, revealArray),\n      amount,\n      stopLoss,\n      stopGain,\n      count\n    );\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable virtual override {\n    console.log(\"From SC: Encoded Side: %s\", side);\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function getNewBombIndex(\n    uint8 startingIndex,\n    bool[25] memory currentMap,\n    uint8 stepCount\n  ) public pure returns (uint8) {\n    uint i;\n    // Iterate stepCount amount\n    for (i = 0; i < stepCount; i++) {\n      // Check if it is a bomb\n      bool isBomb = currentMap[(startingIndex + i) % 25];\n      if (isBomb) {\n        // If it is a bomb, increase the stepCount so that, we would have an extra iteration for each bomb we have seen\n        // Which could also be understood as, skipping the bombs or not incremeting our count if it was a bomb\n        stepCount++;\n      }\n    }\n    return uint8((startingIndex + i) % 25);\n  }\n\n  // We must have bombCount amount of randomNumbers to represent each bomb\n  // Since we need to have randomNumbers from 0 to 25, randomNumber would represent the bomb index, a randomNumber could be represented by a byte (0x00-0xff)\n  // NOTE: randomNumber will not directly represent bombIndex, because in that case, we might get the same randomNumber therefore try to put 2 bombs to the same place.\n  // NOTE: Since we dont want to put 2 bombs to a same place, we can try to handle it by adding 1 till we find a new empty place.\n  // NOTE: But the upper approach would create a case where positions that are adjacent to the bomb would have a higher chance to get a new bomb\n  // NOTE: Since, we want each position to have the same probability to contain a bomb, we will do something different\n  // NOTE: What we will do is, with first randomNumber we will put a bomb there, and we will have a `currentIndex` just after the bomb\n  // NOTE: With the second randomNumber, we will start from our `currentIndex` and add secondRandomNumber amount positions. Put a bomb there and update `currentIndex` just after the bomb\n  // NOTE: During iterating, if we encounter a bomb, we will increase our iteration count. With this update, we will never put a second bomb to the same place\n  // We should be able to create up to 24 randomNumbers (0 < randomNumber < 24) from a single randomNumber provided from VRF which is a uint256 randomNumber\n  // VRF returns us a 32 byte randomNumber, what we will do is, get each byte of the vrf randomNumber (starting from most significant byte, rightmost byte)\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    // Given uint256 randomNumber. Based on the bombCount, inside the betSide, create bombMap\n    (uint8 bombCount, , ) = decodeSide(betSide);\n    console.log(\"From SC: bombCount after decode: \", bombCount);\n    bool[25] memory bombMap;\n    uint8 currentIndex = 0;\n    for (uint8 i = 0; i < bombCount; i++) {\n      // Create new randomNumbers on each iteration from a single randomNumber\n      // NOTE: What I had in mind was to get the (mod 100) for the random number to access the last 2 digits of the random number\n      // NOTE: Since those 2 digits can represent 0-99 and each number has the same probability, I can just take (mod 25) and numbers from 0-24 would have the same probability\n      // NOTE: And then with those 2 digits, I would take (mod 25) to get randomNumber between 0-24\n      // NOTE: Since, I am taking a (mod 25) at the end I dont have to take (mod 100) beforehand\n      // NOTE: Because, everything before the last 2 digits is divisable by 100, and therefore divisable by 25\n      // NOTE: So, I am only taking a (mod 25) and then dividing the original randomNumber by 100 to have new last 2 digits on each iteration\n      // Get randomNumber based on last 2 digits\n      uint8 currentRandomNumber = uint8(randomNumber % 25);\n      // Update the original randomNumber to have new randomNumber on each iteration\n      randomNumber = randomNumber / 100;\n\n      // Get index for the new bomb\n      uint8 newBombIndex = getNewBombIndex(\n        currentIndex,\n        bombMap,\n        currentRandomNumber\n      );\n\n      // Set specific bit to true to represent that there is a bomb\n\n      bombMap[newBombIndex] = true;\n      // Set the currentIndex to be the next index after bomb\n      currentIndex = (newBombIndex + 1) % 25;\n    }\n    return boolArrayToUint256(bombMap);\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    (, , bool[25] memory revealArray) = decodeSide(betSide);\n    (, , bool[25] memory bombMap) = decodeSide(houseSide);\n    bool hit = false;\n    for (uint i = 0; i < 25; i++) {\n      if (revealArray[i] && bombMap[i]) {\n        hit = true;\n        break;\n      }\n    }\n    return hit ? 0 : betSide;\n  }\n\n  // TODO: Not sure, but check if it would be more optimized if we stored the probabilies (or multipliers) rather than calculating from scratch everytime\n  // TODO: It is, if we retrieve a value from a mapping(uint => mapping(uint => uint)), this function would cost 3282 gas\n  // TODO: With iterating and calculating probability it would cost => 7277 gas for 4 revealCount, 2594 gas for 1 revealCount, 4155 gas for 2 revealCount\n  // TODO: Initialize the values inside the constructor\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view virtual override returns (uint) {\n    if (outcome == 0) return 0;\n    (uint8 bombCount, uint8 revealCount, ) = decodeSide(betSide);\n    uint aggregateMultiplier = 1 ether;\n    /**\n     * (25 - i) / (25 - i - bombCount)\n     * where i represents the iteration count. i will start from 0 and go till revealCount (inclusive)\n     * Example => revealCount = 3, bombCount = 2\n     *         => (25 / 23) * (24 / 22) * (23 / 21)\n     */\n    for (uint i = 0; i < revealCount; i++) {\n      aggregateMultiplier = BetHelpers.mulDiv(\n        aggregateMultiplier,\n        BetHelpers.mulDiv(\n          (25 - i) * 10 ** 18,\n          1 ether,\n          (25 - i - bombCount) * 10 ** 18\n        ),\n        1 ether\n      );\n    }\n\n    return aggregateMultiplier;\n  }\n\n  // This function is only for the usage of frontend.\n  // If user wants to reveal positions [2, 24], this function would return the corresponding uint32 to represent it correctly\n  // In the case of [2, 24], it would be something like 0010 000 0000 0000 0000 0000 0100 = 16777220\n  function createRevealArray(\n    uint[] calldata revealPositions\n  ) external pure returns (bool[25] memory) {\n    uint len = revealPositions.length;\n    bool[25] memory revealArray;\n    for (uint i = 0; i < len; i++) {\n      revealArray[revealPositions[i]] = true;\n    }\n    return revealArray;\n  }\n}\n"
    },
    "contracts/FareCoinFlip.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareCoinFlip is BaseSPGame, VRFRequester {\n  /**\n   * Network: Mumbai\n   * Aggregator: MATIC/USD\n   * Address: 0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada\n   *\n   * Network: Mumbai\n   * Aggregator: LINK/USD\n   * Address: 0x1C2252aeeD50e0c9B64bDfF2735Ee3C932F5C408\n   */\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    // address _nativeTokenAggregatorAddress,\n    // address _linkTokenAggregatorAddress,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(\n      _subscriptionId,\n      // _nativeTokenAggregatorAddress,\n      // _linkTokenAggregatorAddress,\n      _vrfCoordinator\n    )\n  {}\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 2;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    return betSide == houseSide ? 1 : 0;\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    return outcome == 1 ? multiplier * 2 : 0;\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(side < 2, \"Side can only be 0 or 1\");\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n}\n"
    },
    "contracts/FareProxyOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/OFTCore.sol\";\nimport \"./interfaces/IFareToken.sol\";\n\n// @NOTE inside OFT.sol contract there is this note: \"override decimal() function is needed\"\ncontract FareProxyOFT is OFTCore {\n  // using SafeERC20 for IERC20;\n\n  IFareToken internal immutable fareToken;\n\n  constructor(address _lzEndpoint, address _token) OFTCore(_lzEndpoint) {\n    fareToken = IFareToken(_token);\n  }\n\n  function circulatingSupply() public view virtual override returns (uint) {\n    unchecked {\n      return fareToken.totalSupply();\n    }\n  }\n\n  function token() public view virtual override returns (address) {\n    return address(fareToken);\n  }\n\n  function _debitFrom(\n    address _from,\n    uint16,\n    bytes memory,\n    uint _amount\n  ) internal virtual override returns (uint) {\n    require(_from == _msgSender(), \"ProxyOFT: owner is not send caller\");\n    uint before = fareToken.totalSupply();\n    fareToken.burnFare(_from, _amount);\n    return before - fareToken.totalSupply();\n  }\n\n  function _creditTo(\n    uint16,\n    address _toAddress,\n    uint _amount\n  ) internal virtual override returns (uint) {\n    uint before = fareToken.totalSupply();\n    fareToken.mintFare(_toAddress, _amount);\n    return fareToken.totalSupply() - before;\n  }\n}\n"
    },
    "contracts/FareRollOver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareRollOver is BaseSPGame, VRFRequester {\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {}\n\n  // To have 2 digit precision after the dot (ex: 23.45). When user inputs 4567 it represents 45.67\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(\n      side >= 500 && side <= 9990,\n      \"Side should be in between 5% (500) and 99.90% (9900)\"\n    );\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal virtual override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 10000;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    return houseSide >= betSide ? 1 : 0;\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    return ((outcome * multiplier * 10000) / (10000 - betSide));\n  }\n}\n"
    },
    "contracts/FareRoulette.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareRoulette is BaseSPGame, VRFRequester {\n  enum COLOR {\n    GREEN,\n    RED,\n    BLACK\n  }\n\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {\n    // For roulette, we are not calculating the chances and deducting a constant houseEdge from payout\n    // Rather we have specific payouts, we are setting houseEdge as 0\n    setHouseEdge(0);\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(side < 46, \"Side should be >=0 and <46\");\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 37;\n  }\n\n  // Assuming betSide is 0<=betSide<=45\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    if (betSide <= 36) {\n      return betSide == houseSide ? 36 : 0;\n    } else if (betSide == 37 || betSide == 38) {\n      // Check isRed (37) or isBlack (38)\n      COLOR houseColor = getColor(houseSide);\n      // red is represented as 1, black is represented as 2\n      // players bet on red is represented as 37, on black as 38\n      // Therefore, betSide % 36 will give us either 1 or 2\n      // Where again 1 is red and black is 2\n      // Therefore, we compare the equivilance to check if player won their black or red bet\n      return uint(houseColor) == betSide % 36 ? 2 : 0;\n    } else if (betSide == 39) {\n      // Check is 1to18\n      return houseSide > 0 && houseSide <= 18 ? 2 : 0;\n    } else if (betSide == 40) {\n      // Check is 19to36\n      return houseSide > 18 && houseSide <= 36 ? 2 : 0;\n    } else if (betSide == 41) {\n      // Check isOdd\n      return (houseSide % 2) * 2;\n    } else if (betSide == 42) {\n      // Check isEven\n      // NOTE: 0 is not considered as even. First ternary operation is for that case\n      return houseSide == 0 ? 0 : houseSide % 2 == 0 ? 2 : 0;\n    } else if (betSide == 43) {\n      // Check first dozen <1to12>\n      return houseSide > 0 && houseSide <= 12 ? 3 : 0;\n    } else if (betSide == 44) {\n      // Check second dozen <13to24>\n      return houseSide > 12 && houseSide <= 24 ? 3 : 0;\n    } else {\n      // Check second dozen <25to36>\n      return houseSide > 24 && houseSide <= 36 ? 3 : 0;\n    }\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    // Given if player wins outcome returns 1 else 0\n    return outcome * multiplier;\n  }\n\n  // function gameSpecificGetOutcome(\n  //     uint betSide,\n  //     uint houseSide\n  // ) public override returns (uint) {\n  //     if (betSide <= 36) {\n  //         return betSide == houseSide ? 1 : 0;\n  //     } else if (betSide == 37 || betSide == 38) {\n  //         // Check isRed (37) or isBlack (38)\n  //         COLOR houseColor = getColor(houseSide);\n  //         // red is represented as 1, black is represented as 2\n  //         // players bet on red is represented as 37, on black as 38\n  //         // Therefore, betSide % 36 will give us either 1 or 2\n  //         // Where again 1 is red and black is 2\n  //         // Therefore, we compare the equivilance to check if player won their black or red bet\n  //         return uint(houseColor) == betSide % 36 ? 1 : 0;\n  //     } else if (betSide == 39) {\n  //         // Check is 1to18\n  //         return houseSide > 0 && houseSide <= 18 ? 1 : 0;\n  //     } else if (betSide == 40) {\n  //         // Check is 19to36\n  //         return houseSide > 18 && houseSide <= 36 ? 1 : 0;\n  //     } else if (betSide == 41) {\n  //         // Check isOdd\n  //         return houseSide % 2;\n  //     } else if (betSide == 42) {\n  //         // Check isEven\n  //         return houseSide % 2 == 0 ? 1 : 0;\n  //     } else if (betSide == 43) {\n  //         // Check first dozen <1to12>\n  //         return houseSide > 0 && houseSide <= 12 ? 1 : 0;\n  //     } else if (betSide == 44) {\n  //         // Check second dozen <13to24>\n  //         return houseSide > 12 && houseSide <= 24 ? 1 : 0;\n  //     } else if (betSide == 45) {\n  //         // Check second dozen <13to24>\n  //         return houseSide > 24 && houseSide <= 36 ? 1 : 0;\n  //     }\n  // }\n\n  // function gameSpecificGetMultiplier(\n  //     uint outcome,\n  //     uint betSide\n  // ) public override returns (uint) {\n  //     // Given if player wins outcome returns 1 else 0\n  //     return\n  //         outcome * multiplier * getPotentialMultiplierFromBetSide(betSide);\n  // }\n\n  // function getPotentialMultiplierFromBetSide(\n  //     uint betSide\n  // ) private pure returns (uint) {\n  //     // Check if player played on a specific number\n  //     if (betSide <= 36) {\n  //         return 36;\n  //     } else if (betSide <= 42) {\n  //         // Check if player played on something that returns double.\n  //         // red (37), black (38), 1 to 18 (39), 19 to 36 (40), odd (41), even (42)\n  //         return 2;\n  //     } else {\n  //         // Should be 43, 44, 45 (right now 46 does not exist)\n  //         // Check if player played on something that returns triple.\n  //         // 1st dozen <1 to 12> (43), 2nd dozen <13 to 24> (44), 3rd dozen <25 to 26> (45)\n  //         return 3;\n  //     }\n  // }\n\n  // With assumption that given uint is 0<=houseSide<=36\n  function getColor(uint houseSide) private pure returns (COLOR) {\n    if (houseSide == 0) {\n      return COLOR.GREEN;\n    } else if (houseSide >= 1 && houseSide <= 10) {\n      if (houseSide % 2 == 0) {\n        return COLOR.BLACK;\n      } else {\n        return COLOR.RED;\n      }\n    } else if (houseSide >= 11 && houseSide <= 18) {\n      if (houseSide % 2 == 0) {\n        return COLOR.RED;\n      } else {\n        return COLOR.BLACK;\n      }\n    } else if (houseSide >= 19 && houseSide <= 28) {\n      if (houseSide % 2 == 0) {\n        return COLOR.BLACK;\n      } else {\n        return COLOR.RED;\n      }\n    } else {\n      if (houseSide % 2 == 0) {\n        return COLOR.RED;\n      } else {\n        return COLOR.BLACK;\n      }\n    }\n  }\n}\n"
    },
    "contracts/FareRPS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./baseGames/singleplayer/BaseSPGame.sol\";\nimport \"./requesters/VRFRequester.sol\";\n\ncontract FareRPS is BaseSPGame, VRFRequester {\n  enum LDW {\n    LOSE,\n    DRAW,\n    WIN\n  }\n\n  // Represents side\n  // 0 => rock\n  // 1 => paper\n  // 2 => scissors\n  enum RPS {\n    ROCK,\n    PAPER,\n    SCISSORS\n  }\n\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(_subscriptionId, _vrfCoordinator)\n  {}\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(side < 3, \"Side can only be 0, 1 or 2\");\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 3;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    return uint256(uint8(calculateOutcome(RPS(betSide), RPS(houseSide % 3))));\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    return multiplier * outcome;\n  }\n\n  /* I know writing smart code is not the best practice but I enjoyed trying to find pattern for this one. \n    Given Rock is 0, Paper is 1, Scissors is 2 and  => R(0), P(1), S(2)\n    Outcomes Lose is 0, Draw is 1, Win is 2 => L(0), D(1), W(2)\n    If we draw a matrix to inspect if any patterns exist it would be like this: \n        - column headers represent player moves\n        - row headers represent qnrg moves\n\n         | R(0) | P(1) | S(2)\n    ---------------------------\n    R(0) | D(1) | W(2) | L(0)\n    ---------------------------\n    P(1) | L(0) | D(1) | W(2)\n    ---------------------------\n    S(2) | W(2) | L(0) | D(1)\n    \n\n    From the pattern here is the formula => LDW[(Player + 2 * houseSide + 1) % 3]\n    \n    Here is how I found out the equation =>\n    From the pattern I have tried and seen a formula that holds for each case => LDW[(Player + 2 * houseSide + 1) % 3]\n        So, when you multiply houseSide's move with 2, add Player's move, add 1 and take modulo for 3. You will have the correct index for LDW enum\n        NOTE: If I had choosen DWL equation would be => DWL[(Player + 2 * houseSide) % 3] but I have choosen LDW intentionly for the index of the result to represent multiplier\n        This way LDW's uint8 value also represents the multiplier (0, 1, 2)\n        For example when outcome is L (0) payout would be multiplied with 0. For D (1) it would be multiplied with 1. For W (2) it would be multiplied with 2.\n    When you take a look at the rows, they always go as LDW (our order). So, when player increases by one result increases by one as well.\n    Therefore, Player will be multiplied by 1 in our equation. \n    When you take a look at the columns. they always go as DLW (not our order). But, if you go 2 steps each time, it will be our order\n    Therefore, houseSide will be multiplied by 2 in our equation.\n    We have the multipliers for Player and houseSide values now we have to find the offset value by giving values for one point. \n    Current equation => LDW[(Player + 2 * houseSide + x) % 3]\n    Given the (Player, houseSide) => (R,P) => (0,1) => L (0) => 0 = (Player + 2 * houseSide + x) % 3\n    From the upper equation when we put the values in => 0 = (0 + 2 * 1 + x) % 3 => x = 1 (mod 3)\n    Therefore x = 1, 4, 7... (x = 1 (mod 3)) let's take x = 1 to make it easier\n    Our equation results to LDW[(PLayer + 2 * houseSide + 1) % 3]\n    */\n  function calculateOutcome(\n    RPS player,\n    RPS houseSide\n  ) public pure returns (LDW) {\n    return LDW((uint8(player) + 2 * uint8(houseSide) + 1) % 3);\n  }\n}\n"
    },
    "contracts/FareSpin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./interfaces/IFareToken.sol\";\n\ncontract FareSpin is ReentrancyGuard, Pausable {\n  using Counters for Counters.Counter;\n\n  /* Global Variables START */\n  address private _owner;\n  IFareToken private fareToken;\n  Counters.Counter private _currentRoundId;\n  Counters.Counter private _currentContractModeId;\n\n  // Contract expected value % calculation -> ((CONTRACT_EXPECTED_VALUE_CEILING - contractMode.contractExpectedValueFloor) / CONTRACT_EXPECTED_VALUE_CEILING) / 100 = contractExpectedValuePercentage\n  uint256 public constant CONTRACT_EXPECTED_VALUE_CEILING = 10**18;\n\n  uint256 public constant REWARDS_MINT_CAP = 10**17; // 10%\n  uint256 public rewardsMint = 10**16; // Percent to rewards on entry\n  address public rewardsAddress;\n\n  bool public isRoundPaused = false;\n  // uint256 public withdrawalPeriod = 1 seconds;\n  uint256 public withdrawalPeriod = 3 hours;\n\n  /* Global Variables END */\n\n  /* Structs START */\n  struct Entry {\n    uint256 amount;\n    uint256 contractModeId;\n    uint256 pickedNumber;\n  }\n\n  struct BatchEntry {\n    uint256 batchEntryId; // Relates to index position in rounds[roundId].users[batchEntryId]\n    address user;\n    bool settled;\n    uint256 settledAt;\n    uint256 totalEntryAmount;\n    uint256 totalMintAmount;\n    uint256 placedAt;\n    uint256 withdrewAt;\n    Entry[] entries;\n  }\n\n  struct ContractMode {\n    uint256 id;\n    uint256 cardinality;\n    uint256 contractExpectedValueFloor;\n    uint256 mintMultiplier;\n    uint256 minAmount;\n    uint256 maxAmount;\n    uint256 entryLimit;\n    bool isActive;\n  }\n\n  struct Eliminator {\n    uint256 contractModeId;\n    uint256 recordedExpectedValueFloor; // contractModeFloor at the time of the round\n    bool isEliminator;\n  }\n\n  struct Round {\n    uint256 id;\n    uint256 startedAt;\n    uint256 endedAt;\n    bytes32 randomHash;\n    bytes32 revealKey;\n    uint256 fullRandomNum;\n    uint256 randomNum;\n    uint256 randomEliminator;\n    address[] users; // User addresses in round used to reference BatchEntry mapping\n    Eliminator[] eliminators;\n    /* Eliminator[] is the length of contractModes at the time the round was concluded\n         Since contractModeFloors can be adjusted individually we need to store the contractModeFloors each round */\n  }\n\n  struct EntryHistory {\n    uint256 gmAmount; // totalAmount placed for given contractMode\n    uint256 entryLimit; // amount of entries placed for given contractMode\n    bool[] pickedList;\n  }\n  /* Structs END */\n\n  /* Modifiers START */\n  modifier onlyOwner() {\n    require(_owner == msg.sender, \"Caller is not the owner\");\n    _;\n  }\n  /* Modifiers END */\n\n  /* Mappings START */\n  mapping(uint256 => ContractMode) public contractModes; // contractModeId => ContractMode\n  mapping(uint256 => Round) public rounds; // roundId => Round\n  mapping(uint256 => mapping(address => BatchEntry)) public batchEntryMap; // roundId => userAddress => BatchEntry\n  mapping(uint256 => bytes32) public randomHashMap; // roundId => bytes32(key to reveal randomHash)\n  /* Mappings END */\n\n  /* Events START */\n  event ContractModeUpdated(uint256 indexed contractModeId);\n  event EntrySubmitted(\n    uint256 indexed roundId,\n    uint256 indexed batchId,\n    address indexed user\n  );\n  event EntrySettled(\n    uint256 indexed roundId,\n    address indexed user,\n    bool hasMinted\n  );\n  event BatchEntriesSettled(address indexed user, uint256[] roundIds);\n  event RoundConcluded(\n    uint256 indexed roundId,\n    bytes32 indexed revealKey,\n    uint256 fullRandomNum,\n    uint256 randomNum,\n    uint256 randomEliminator\n  );\n  event NewRoundStarted(\n    uint256 indexed roundId,\n    bytes32 indexed randomHash,\n    uint256 startedAt\n  );\n  event BatchEntryWithdraw(uint256 indexed roundId, address indexed user);\n  event NFTMint(uint256 indexed roundId, address indexed user);\n  event RoundPausedChanged(bool isPaused);\n\n  /* Events END */\n\n  constructor(address _fareTokenAddress, address _rewardsAddress) {\n    require(\n      _fareTokenAddress != address(0),\n      \"Not a valid address for _fareTokenAddress\"\n    );\n    require(\n      _rewardsAddress != address(0),\n      \"Not a valid address for _rewardsAddress\"\n    );\n\n    _owner = msg.sender; // Set owner to contract creator\n    fareToken = IFareToken(_fareTokenAddress);\n    rewardsAddress = _rewardsAddress;\n  }\n\n  /* Getters START */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  function getFareTokenAddress() public view returns (address fareAddress) {\n    fareAddress = address(fareToken);\n  }\n\n  function getCurrentContractModeId() public view returns (uint256 id) {\n    id = _currentContractModeId.current();\n  }\n\n  function getCurrentRoundId() public view returns (uint256 id) {\n    id = _currentRoundId.current();\n  }\n\n  function getBatchEntryCount(uint256 roundId)\n    public\n    view\n    returns (uint256 count)\n  {\n    count = rounds[roundId].users.length;\n  }\n\n  function getEntryCount(uint256 roundId, address user)\n    public\n    view\n    returns (uint256 count)\n  {\n    count = batchEntryMap[roundId][user].entries.length;\n  }\n\n  function getEntriesByRoundUser(uint256 roundId, address user)\n    public\n    view\n    returns (Entry[] memory)\n  {\n    Entry[] memory entries = batchEntryMap[roundId][user].entries;\n    return entries;\n  }\n\n  function getEntryByIndex(\n    uint256 roundId,\n    address user,\n    uint256 entryIdx\n  ) public view returns (Entry memory) {\n    Entry memory entry = batchEntryMap[roundId][user].entries[entryIdx];\n    return entry;\n  }\n\n  function getAllUsersByRoundId(uint256 roundId)\n    public\n    view\n    returns (address[] memory users)\n  {\n    users = rounds[roundId].users;\n  }\n\n  function getIsEliminator(uint256 roundId, uint256 contractModeId)\n    public\n    view\n    returns (bool isEliminator)\n  {\n    isEliminator = rounds[roundId].eliminators[contractModeId].isEliminator;\n  }\n\n  function getEliminatorsByRoundId(uint256 roundId)\n    public\n    view\n    returns (Eliminator[] memory eliminators)\n  {\n    eliminators = rounds[roundId].eliminators;\n  }\n\n  /* Getters END */\n\n  /* Setters START */\n  function setFareToken(address _fareTokenAddress) external onlyOwner {\n    require(_fareTokenAddress != address(0), \"_fareTokenAddress is invalid\");\n    fareToken = IFareToken(_fareTokenAddress);\n  }\n\n  function setRewardsAddress(address _rewardsAddress) external onlyOwner {\n    require(_rewardsAddress != address(0), \"_rewardsAddress is invalid\");\n    rewardsAddress = _rewardsAddress;\n  }\n\n  function setRewardsMint(uint256 percent) external onlyOwner {\n    require(percent <= REWARDS_MINT_CAP, \"Rewards mint % must be <= 10%\");\n    rewardsMint = percent;\n  }\n\n  function setContractMode(\n    uint256 cardinality,\n    uint256 contractExpectedValueFloor,\n    uint256 mintMultiplier,\n    uint256 minAmount,\n    uint256 maxAmount,\n    uint256 entryLimit\n  ) external onlyOwner {\n    require(entryLimit <= cardinality, \"Limit greater than cardinality\");\n    if ((minAmount > 0 && maxAmount > 0) && minAmount > maxAmount) {\n      revert(\"minAmount greater than maxAmount\");\n    }\n\n    uint256 gmid = _currentContractModeId.current();\n    contractModes[gmid] = ContractMode({\n      id: gmid,\n      cardinality: cardinality,\n      contractExpectedValueFloor: contractExpectedValueFloor,\n      mintMultiplier: mintMultiplier,\n      minAmount: minAmount,\n      maxAmount: maxAmount,\n      entryLimit: entryLimit,\n      isActive: true\n    });\n\n    _currentContractModeId.increment();\n    emit ContractModeUpdated(gmid);\n  }\n\n  function setContractModeMinMax(\n    uint256 contractModeId,\n    uint256 minAmount,\n    uint256 maxAmount\n  ) external onlyOwner {\n    if ((minAmount > 0 && maxAmount > 0) && minAmount > maxAmount) {\n      revert(\"minAmount greater than maxAmount\");\n    }\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n\n    contractModes[contractModeId].minAmount = minAmount;\n    contractModes[contractModeId].maxAmount = maxAmount;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractModeIsActive(uint256 contractModeId, bool isActive)\n    external\n    onlyOwner\n  {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n\n    contractModes[contractModeId].isActive = isActive;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractExpectedValueFloor(\n    uint256 contractModeId,\n    uint256 _contractExpectedValueFloor\n  ) external onlyOwner {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n    require(\n      _contractExpectedValueFloor < CONTRACT_EXPECTED_VALUE_CEILING,\n      \"Floor must be less than ceiling\"\n    );\n\n    contractModes[contractModeId]\n      .contractExpectedValueFloor = _contractExpectedValueFloor;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractModeEntryLimit(uint256 contractModeId, uint256 entryLimit)\n    external\n    onlyOwner\n  {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n    require(\n      entryLimit <= contractModes[contractModeId].cardinality,\n      \"entryLimit > cardinality\"\n    );\n\n    contractModes[contractModeId].entryLimit = entryLimit;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setEliminators(uint256 randomEliminator, uint256 roundId) internal {\n    uint256 cgmid = _currentContractModeId.current();\n\n    for (uint256 gmid = 0; gmid < cgmid; gmid++) {\n      rounds[roundId].eliminators.push(\n        Eliminator({\n          contractModeId: gmid,\n          recordedExpectedValueFloor: contractModes[gmid]\n            .contractExpectedValueFloor,\n          isEliminator: randomEliminator >=\n            contractModes[gmid].contractExpectedValueFloor\n        })\n      );\n    }\n  }\n\n  function setRoundPaused(bool paused) public onlyOwner {\n    isRoundPaused = paused;\n    emit RoundPausedChanged(paused);\n  }\n\n  function setPauseContract(bool paused) public onlyOwner {\n    if (paused) {\n      _pause();\n    } else {\n      _unpause();\n    }\n  }\n\n  /* Setters END */\n\n  function createEntryHistory() internal view returns (EntryHistory[] memory) {\n    uint256 contractModeCount = _currentContractModeId.current();\n    EntryHistory[] memory entryHistory = new EntryHistory[](contractModeCount);\n\n    for (uint256 gmid = 0; gmid < entryHistory.length; gmid++) {\n      entryHistory[gmid] = EntryHistory({\n        gmAmount: 0,\n        entryLimit: 0,\n        pickedList: new bool[](contractModes[gmid].cardinality)\n      });\n    }\n\n    return entryHistory;\n  }\n\n  function placeBatchEntry(Entry[] memory entries)\n    external\n    nonReentrant\n    whenNotPaused\n  {\n    require(!isRoundPaused, \"Round is paused\");\n    require(\n      rounds[_currentRoundId.current()].startedAt > 0 &&\n        rounds[_currentRoundId.current()].endedAt == 0,\n      \"Round has not started yet.\"\n    );\n\n    uint256 contractModeCount = _currentContractModeId.current();\n    uint256 entryCount = entries.length;\n    uint256 rid = _currentRoundId.current();\n    uint256 batchEntryId = rounds[rid].users.length;\n\n    uint256 totalEntryAmount = 0;\n    EntryHistory[] memory entryHistory = createEntryHistory(); // Array index is contractModeId | used to enforce entry requirements\n\n    BatchEntry storage batchEntry = batchEntryMap[rid][msg.sender]; // Get storage reference for batchEntry by userAddress\n\n    require(\n      batchEntry.totalEntryAmount == 0,\n      \"Already entered in current round\"\n    );\n\n    for (uint256 idx = 0; idx < entryCount; idx++) {\n      require(\n        entries[idx].contractModeId < _currentContractModeId.current(),\n        \"Invalid contract mode\"\n      );\n      ContractMode memory contractMode = contractModes[\n        entries[idx].contractModeId\n      ];\n\n      require(entries[idx].amount != 0, \"Amount cannot be zero\");\n      require(contractMode.isActive, \"Contract mode is not active\");\n      require(\n        entries[idx].pickedNumber < contractMode.cardinality,\n        \"Invalid picked number\"\n      );\n      // Ensure number has already been picked by user\n      require(\n        !entryHistory[contractMode.id].pickedList[entries[idx].pickedNumber],\n        \"Duplicate pickedNumber by contract\"\n      );\n\n      entryHistory[contractMode.id].pickedList[\n        entries[idx].pickedNumber\n      ] = true;\n\n      // Ensure the max entry amount isn't exceeded for the specific contract mode\n      if (contractMode.maxAmount > 0) {\n        // If maxAmount is set(> 0), then keep track of contractMode min/max requirements\n        entryHistory[contractMode.id].gmAmount =\n          entryHistory[contractMode.id].gmAmount +\n          entries[idx].amount;\n        require(\n          entryHistory[contractMode.id].gmAmount < contractMode.maxAmount,\n          \"Contract mode max amount exceeded\"\n        );\n      }\n\n      entryHistory[contractMode.id].entryLimit =\n        entryHistory[contractMode.id].entryLimit +\n        1;\n      require(\n        entryHistory[contractMode.id].entryLimit <= contractMode.entryLimit,\n        \"Contract mode entry limit exceeded\"\n      );\n\n      totalEntryAmount = totalEntryAmount + entries[idx].amount;\n\n      batchEntry.entries.push(\n        Entry({\n          contractModeId: contractMode.id,\n          pickedNumber: entries[idx].pickedNumber,\n          amount: entries[idx].amount\n        })\n      );\n    }\n\n    // If minAmount is set(> 0) for a contractMode, ensure the minAmount for each contractMode was met\n    for (uint256 gmid = 0; gmid < contractModeCount; gmid++) {\n      if (\n        contractModes[gmid].minAmount > 0 &&\n        entryHistory[gmid].gmAmount < contractModes[gmid].minAmount\n      ) {\n        revert(\"Contract mode min amount not met\");\n      }\n    }\n\n    batchEntry.batchEntryId = batchEntryId; // Current index position for user\n    batchEntry.user = msg.sender;\n    batchEntry.totalEntryAmount = totalEntryAmount; // Sum of all entry amounts\n    batchEntry.totalMintAmount = 0; // Probably don't need this since it defaults to 0\n    batchEntry.settled = false; // Probably don't need this since it defaults to false\n    batchEntry.placedAt = block.timestamp;\n\n    rounds[rid].users.push(msg.sender); // Add user's address to round users array\n\n    fareToken.burnFare(msg.sender, totalEntryAmount);\n    fareToken.mintFare(\n      rewardsAddress,\n      (totalEntryAmount * rewardsMint) / 10**18\n    );\n\n    emit EntrySubmitted(rid, batchEntryId, msg.sender);\n  }\n\n  function withdrawalBatchEntry() external nonReentrant whenNotPaused {\n    uint256 rid = _currentRoundId.current();\n    BatchEntry storage batchEntry = batchEntryMap[rid][msg.sender];\n    require(batchEntry.totalEntryAmount != 0, \"Batch entry does not exist\");\n    require(batchEntry.withdrewAt == 0, \"Already withdrew entry\");\n    require(\n      (batchEntry.placedAt + withdrawalPeriod) < block.timestamp,\n      \"Withdrawal not available yet\"\n    );\n    require(!batchEntry.settled, \"Entry already settled\");\n\n    batchEntry.withdrewAt = block.timestamp;\n\n    fareToken.mintFare(msg.sender, batchEntry.totalEntryAmount);\n\n    fareToken.burnFare(\n      rewardsAddress,\n      (batchEntry.totalEntryAmount * rewardsMint) / 10**18\n    );\n    emit BatchEntryWithdraw(rid, msg.sender);\n  }\n\n  function settleBatchEntry(uint256 roundId, address user)\n    external\n    nonReentrant\n    whenNotPaused\n  {\n    BatchEntry storage batchEntry = batchEntryMap[roundId][user];\n    Entry[] memory entries = batchEntry.entries;\n    require(batchEntry.withdrewAt == 0, \"You already withdrew from the round\");\n    require(batchEntry.totalEntryAmount != 0, \"Batch entry does not exist\");\n    require(!batchEntry.settled, \"Entry already settled\");\n    require(_currentRoundId.current() > roundId, \"Round not yet resolved\");\n\n    bool hasMintedNFT = false;\n    uint256 totalMintAmount = 0;\n\n    for (uint256 idx = 0; idx < entries.length; idx++) {\n      if (\n        getIsEliminator(roundId, entries[idx].contractModeId) && !hasMintedNFT\n      ) {\n        mintEliminatorNFT(roundId, batchEntry.user);\n        hasMintedNFT = true;\n      } else {\n        ContractMode memory contractMode = contractModes[\n          entries[idx].contractModeId\n        ];\n\n        uint256 rng = rounds[roundId].randomNum;\n\n        if (rng % contractMode.cardinality == entries[idx].pickedNumber) {\n          totalMintAmount += (entries[idx].amount *\n            contractMode.mintMultiplier);\n        }\n      }\n    }\n\n    if (totalMintAmount > 0) {\n      fareToken.mintFare(batchEntry.user, totalMintAmount);\n      batchEntry.totalMintAmount = totalMintAmount;\n    }\n\n    batchEntry.settled = true;\n    batchEntry.settledAt = block.timestamp;\n\n    emit EntrySettled(roundId, batchEntry.user, batchEntry.totalMintAmount > 0);\n  }\n\n  function batchSettleEntries(uint256[] memory roundIds, address user)\n    public\n    nonReentrant\n    whenNotPaused\n  {\n    require(roundIds.length > 0, \"BatchEntry list cannot be empty.\");\n    require(\n      roundIds.length < 21,\n      \"You can only settle 20 batch entries at a time.\"\n    );\n    for (uint256 index = 0; index < roundIds.length; index++) {\n      uint256 roundId = roundIds[index];\n      BatchEntry storage batchEntry = batchEntryMap[roundId][user];\n      Entry[] memory entries = batchEntry.entries;\n      require(\n        batchEntry.withdrewAt == 0,\n        \"You already withdrew from the round\"\n      );\n      require(batchEntry.totalEntryAmount != 0, \"Batch entry does not exist\");\n      require(!batchEntry.settled, \"Entry already settled\");\n      require(_currentRoundId.current() > roundId, \"Round not yet resolved\");\n\n      bool hasMintedNFT = false;\n      uint256 totalMintAmount = 0;\n\n      for (uint256 idx = 0; idx < entries.length; idx++) {\n        if (\n          getIsEliminator(roundId, entries[idx].contractModeId) && !hasMintedNFT\n        ) {\n          mintEliminatorNFT(roundId, user);\n          hasMintedNFT = true;\n        } else {\n          ContractMode memory contractMode = contractModes[\n            entries[idx].contractModeId\n          ];\n\n          uint256 rng = rounds[roundId].randomNum;\n\n          if (rng % contractMode.cardinality == entries[idx].pickedNumber) {\n            totalMintAmount += (entries[idx].amount *\n              contractMode.mintMultiplier);\n          }\n        }\n      }\n\n      if (totalMintAmount > 0) {\n        fareToken.mintFare(batchEntry.user, totalMintAmount);\n        batchEntry.totalMintAmount = totalMintAmount;\n      }\n\n      batchEntry.settled = true;\n      batchEntry.settledAt = block.timestamp;\n    }\n\n    emit BatchEntriesSettled(user, roundIds);\n  }\n\n  function concludeRound(bytes32 revealKey, uint256 fullRandomNum)\n    external\n    onlyOwner\n    whenNotPaused\n  {\n    uint256 rid = _currentRoundId.current();\n    Round storage round = rounds[rid];\n\n    require(\n      keccak256(abi.encodePacked(revealKey, fullRandomNum)) == round.randomHash,\n      \"revealKey and randomness is invalid.\"\n    );\n    require(\n      rounds[_currentRoundId.current()].users.length > 0,\n      \"No users in round.\"\n    );\n    require(isRoundPaused, \"Must pause round before concluding.\");\n    require(\n      round.startedAt > 0 && round.endedAt == 0,\n      \"Round already concluded.\"\n    );\n\n    uint256 randomNum = fullRandomNum % 100;\n    uint256 randomEliminator = fullRandomNum % CONTRACT_EXPECTED_VALUE_CEILING;\n\n    round.id = rid;\n    round.fullRandomNum = fullRandomNum;\n    round.randomNum = randomNum;\n    round.revealKey = revealKey;\n    round.randomEliminator = randomEliminator;\n    round.endedAt = block.timestamp;\n\n    // Set Round -> Eliminators[] with current eliminator floors and randomEliminator\n    setEliminators(randomEliminator, rid);\n\n    _currentRoundId.increment();\n    emit RoundConcluded(\n      rid,\n      revealKey,\n      fullRandomNum,\n      randomNum,\n      randomEliminator\n    );\n  }\n\n  function startNewRound(bytes32 randomHash) external onlyOwner whenNotPaused {\n    uint256 rid = _currentRoundId.current();\n    Round storage round = rounds[rid];\n    require(randomHash != bytes32(0), \"randomHash is required.\");\n    require(\n      round.startedAt == 0 && round.endedAt == 0,\n      \"Round already started.\"\n    );\n\n    round.startedAt = block.timestamp;\n    round.randomHash = randomHash;\n    randomHashMap[rid] = randomHash;\n\n    isRoundPaused = false;\n    emit RoundPausedChanged(false);\n    emit NewRoundStarted(rid, randomHash, round.startedAt);\n  }\n\n  function mintEliminatorNFT(uint256 roundId, address user)\n    internal\n    whenNotPaused\n  {\n    emit NFTMint(roundId, user);\n  }\n\n  function getRandomness() private view returns (uint256) {\n    uint256 upperLimit = type(uint256).max;\n    uint256 seed = uint256(\n      keccak256(\n        abi.encodePacked(\n          block.timestamp +\n            block.difficulty +\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) /\n              (block.timestamp)) +\n            block.gaslimit +\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\n              (block.timestamp)) +\n            block.number\n        )\n      )\n    );\n\n    return (seed - ((seed / upperLimit) * upperLimit));\n  }\n}\n"
    },
    "contracts/FareSpinOld.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\nimport \"./interfaces/IFareToken.sol\";\n\ncontract FareSpinOld is ReentrancyGuard, Pausable, VRFConsumerBase {\n  using Counters for Counters.Counter;\n\n  /* Global Variables START */\n  address private _owner;\n  IFareToken private fareToken;\n  Counters.Counter private _currentRoundId;\n  Counters.Counter private _currentContractModeId;\n\n  // Contract expected value % calculation -> ((CONTRACT_EXPECTED_VALUE_CEILING - contractMode.contractExpectedValueFloor) / CONTRACT_EXPECTED_VALUE_CEILING) / 100 = contractExpectedValuePercentage\n  uint256 public constant CONTRACT_EXPECTED_VALUE_CEILING = 10**18;\n\n  uint256 public constant REWARDS_MINT_CAP = 10**17; // 10%\n  uint256 public rewardsMint = 10**16; // Percent to rewards on entry\n  address public rewardsAddress;\n\n  bool public isRoundPaused = false;\n\n  // VRF\n  address public vrfCoordinator;\n  bytes32 internal keyHash;\n  uint256 internal vrfLinkFee;\n  /* Global Variables END */\n\n  /* Structs START */\n  struct Entry {\n    uint256 amount;\n    uint256 contractModeId;\n    uint256 pickedNumber;\n  }\n\n  struct BatchEntry {\n    /* uint256 entryId; // Remove later */\n    uint256 batchEntryId; // Relates to index position in rounds[roundId].users[batchEntryId]\n    address user;\n    bool settled;\n    uint256 totalEntryAmount;\n    uint256 totalMintAmount;\n    /* New properties */\n    Entry[] entries;\n  }\n\n  struct ContractMode {\n    uint256 id;\n    uint256 cardinality;\n    uint256 contractExpectedValueFloor;\n    uint256 mintMultiplier;\n    uint256 minAmount;\n    uint256 maxAmount;\n    uint256 entryLimit;\n    bool isActive;\n  }\n\n  struct Eliminator {\n    uint256 contractModeId;\n    uint256 recordedExpectedValueFloor; // contractModeFloor at the time of the round\n    bool isEliminator;\n  }\n\n  struct Round {\n    uint256 id;\n    uint256 randomNum;\n    uint256 randomEliminator;\n    bytes32 vrfRequestId; // Id provided by Chainlink that references VRF number and backing proof\n    uint256 vrfNum;\n    /* New properties */\n    address[] users; // User addresses in round used to reference BatchEntry mapping\n    Eliminator[] eliminators;\n    /* Eliminator[] is the length of contractModes at the time the round was concluded\n         Since contractModeFloors can be adjusted individually we need to store the contractModeFloors each round */\n  }\n\n  struct EntryHistory {\n    uint256 gmAmount; // totalAmount placed for given contractMode\n    uint256 entryLimit; // amount of entries placed for given contractMode\n    bool[] pickedList;\n  }\n  /* Structs END */\n\n  /* Modifiers START */\n  modifier onlyOwner() {\n    require(_owner == msg.sender, \"Caller is not the owner\");\n    _;\n  }\n  /* Modifiers END */\n\n  /* Mappings START */\n  mapping(uint256 => ContractMode) public contractModes; // contractModeId => ContractMode\n  mapping(uint256 => Round) public rounds; // roundId => Round\n  mapping(uint256 => mapping(address => BatchEntry)) public batchEntryMap; // roundId => userAddress => BatchEntry\n  /* Mappings END */\n\n  /* Events START */\n  event ContractModeUpdated(uint256 indexed contractModeId);\n  event EntrySubmitted(\n    uint256 indexed roundId,\n    uint256 indexed batchId,\n    address indexed user\n  );\n  event EntrySettled(\n    uint256 indexed roundId,\n    address indexed user,\n    bool hasMinted\n  );\n  event RoundConcluded(\n    uint256 indexed roundId,\n    bytes32 indexed vrfRequestId,\n    uint256 randomNum,\n    uint256 randomEliminator\n  );\n  event RandomNumberRequested(bytes32 indexed vrfRequestId);\n  event NFTMint(uint256 indexed roundId, address indexed user);\n  event RoundPausedChanged(bool isPaused);\n\n  /* Events END */\n\n  constructor(\n    address _fareTokenAddress,\n    address _vrfCoordinator,\n    address linkTokenAddress,\n    bytes32 _keyHash,\n    uint256 _vrfLinkFee,\n    address _rewardsAddress\n  ) VRFConsumerBase(_vrfCoordinator, linkTokenAddress) {\n    require(\n      _fareTokenAddress != address(0),\n      \"Not a valid address for _fareTokenAddress\"\n    );\n    require(\n      _vrfCoordinator != address(0),\n      \"Not a valid address for _vrfCoordinator\"\n    );\n    require(\n      linkTokenAddress != address(0),\n      \"Not a valid address for linkTokenAddress\"\n    );\n    require(\n      _rewardsAddress != address(0),\n      \"Not a valid address for _rewardsAddress\"\n    );\n\n    _owner = msg.sender; // Set owner to contract creator\n    vrfCoordinator = _vrfCoordinator;\n    fareToken = IFareToken(_fareTokenAddress);\n    keyHash = _keyHash;\n    vrfLinkFee = _vrfLinkFee; // 0.0001 LINK (Varies by network)\n    rewardsAddress = _rewardsAddress;\n  }\n\n  /* Getters START */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  function getFareTokenAddress() public view returns (address fareAddress) {\n    fareAddress = address(fareToken);\n  }\n\n  function getCurrentContractModeId() public view returns (uint256 id) {\n    id = _currentContractModeId.current();\n  }\n\n  function getCurrentRoundId() public view returns (uint256 id) {\n    id = _currentRoundId.current();\n  }\n\n  function getBatchEntryCount(uint256 roundId)\n    public\n    view\n    returns (uint256 count)\n  {\n    count = rounds[roundId].users.length;\n  }\n\n  function getEntryCount(uint256 roundId, address user)\n    public\n    view\n    returns (uint256 count)\n  {\n    count = batchEntryMap[roundId][user].entries.length;\n  }\n\n  function getEntriesByRoundUser(uint256 roundId, address user)\n    public\n    view\n    returns (Entry[] memory)\n  {\n    Entry[] memory entries = batchEntryMap[roundId][user].entries;\n    return entries;\n  }\n\n  function getEntryByIndex(\n    uint256 roundId,\n    address user,\n    uint256 entryIdx\n  ) public view returns (Entry memory) {\n    Entry memory entry = batchEntryMap[roundId][user].entries[entryIdx];\n    return entry;\n  }\n\n  function getAllUsersByRoundId(uint256 roundId)\n    public\n    view\n    returns (address[] memory users)\n  {\n    users = rounds[roundId].users;\n  }\n\n  function getIsEliminator(uint256 roundId, uint256 contractModeId)\n    public\n    view\n    returns (bool isEliminator)\n  {\n    isEliminator = rounds[roundId].eliminators[contractModeId].isEliminator;\n  }\n\n  function getEliminatorsByRoundId(uint256 roundId)\n    public\n    view\n    returns (Eliminator[] memory eliminators)\n  {\n    eliminators = rounds[roundId].eliminators;\n  }\n\n  /* Getters END */\n\n  /* Setters START */\n  function setFareToken(address _fareTokenAddress) external onlyOwner {\n    require(_fareTokenAddress != address(0), \"_fareTokenAddress is invalid\");\n    fareToken = IFareToken(_fareTokenAddress);\n  }\n\n  function setRewardsAddress(address _rewardsAddress) external onlyOwner {\n    require(_rewardsAddress != address(0), \"_rewardsAddress is invalid\");\n    rewardsAddress = _rewardsAddress;\n  }\n\n  function setRewardsMint(uint256 percent) external onlyOwner {\n    require(percent <= REWARDS_MINT_CAP, \"Rewards mint % must be <= 10%\");\n    rewardsMint = percent;\n  }\n\n  function setContractMode(\n    uint256 cardinality,\n    uint256 contractExpectedValueFloor,\n    uint256 mintMultiplier,\n    uint256 minAmount,\n    uint256 maxAmount,\n    uint256 entryLimit\n  ) external onlyOwner {\n    require(entryLimit <= cardinality, \"Limit greater than cardinality\");\n    if ((minAmount > 0 && maxAmount > 0) && minAmount > maxAmount) {\n      revert(\"minAmount greater than maxAmount\");\n    }\n\n    uint256 gmid = _currentContractModeId.current();\n    contractModes[gmid] = ContractMode({\n      id: gmid,\n      cardinality: cardinality,\n      contractExpectedValueFloor: contractExpectedValueFloor,\n      mintMultiplier: mintMultiplier,\n      minAmount: minAmount,\n      maxAmount: maxAmount,\n      entryLimit: entryLimit,\n      isActive: true\n    });\n\n    _currentContractModeId.increment();\n    emit ContractModeUpdated(gmid);\n  }\n\n  function setContractModeMinMax(\n    uint256 contractModeId,\n    uint256 minAmount,\n    uint256 maxAmount\n  ) external onlyOwner {\n    if ((minAmount > 0 && maxAmount > 0) && minAmount > maxAmount) {\n      revert(\"minAmount greater than maxAmount\");\n    }\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n\n    contractModes[contractModeId].minAmount = minAmount;\n    contractModes[contractModeId].maxAmount = maxAmount;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractModeIsActive(uint256 contractModeId, bool isActive)\n    external\n    onlyOwner\n  {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n\n    contractModes[contractModeId].isActive = isActive;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractExpectedValueFloor(\n    uint256 contractModeId,\n    uint256 _contractExpectedValueFloor\n  ) external onlyOwner {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n    require(\n      _contractExpectedValueFloor < CONTRACT_EXPECTED_VALUE_CEILING,\n      \"Floor must be less than ceiling\"\n    );\n\n    contractModes[contractModeId]\n      .contractExpectedValueFloor = _contractExpectedValueFloor;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setContractModeEntryLimit(uint256 contractModeId, uint256 entryLimit)\n    external\n    onlyOwner\n  {\n    require(\n      contractModeId < _currentContractModeId.current(),\n      \"Invalid contract mode\"\n    );\n    require(\n      entryLimit <= contractModes[contractModeId].cardinality,\n      \"entryLimit > cardinality\"\n    );\n\n    contractModes[contractModeId].entryLimit = entryLimit;\n    emit ContractModeUpdated(contractModeId);\n  }\n\n  function setEliminators(uint256 randomEliminator, uint256 roundId) internal {\n    uint256 cgmid = _currentContractModeId.current();\n\n    for (uint256 gmid = 0; gmid < cgmid; gmid++) {\n      rounds[roundId].eliminators.push(\n        Eliminator({\n          contractModeId: gmid,\n          recordedExpectedValueFloor: contractModes[gmid]\n            .contractExpectedValueFloor,\n          isEliminator: randomEliminator >=\n            contractModes[gmid].contractExpectedValueFloor\n        })\n      );\n    }\n  }\n\n  function setRoundPaused(bool paused) public onlyOwner {\n    isRoundPaused = paused;\n    emit RoundPausedChanged(paused);\n  }\n\n  function setPauseContract(bool paused) public onlyOwner {\n    if (paused) {\n      _pause();\n    } else {\n      _unpause();\n    }\n  }\n\n  /* Setters END */\n\n  function createEntryHistory() internal view returns (EntryHistory[] memory) {\n    uint256 contractModeCount = _currentContractModeId.current();\n    EntryHistory[] memory entryHistory = new EntryHistory[](contractModeCount);\n\n    for (uint256 gmid = 0; gmid < entryHistory.length; gmid++) {\n      entryHistory[gmid] = EntryHistory({\n        gmAmount: 0,\n        entryLimit: 0,\n        pickedList: new bool[](contractModes[gmid].cardinality)\n      });\n    }\n\n    return entryHistory;\n  }\n\n  function placeBatchEntry(Entry[] memory entries)\n    external\n    nonReentrant\n    whenNotPaused\n  {\n    require(!isRoundPaused, \"Round is paused\");\n\n    uint256 contractModeCount = _currentContractModeId.current();\n    uint256 entryCount = entries.length;\n    uint256 rid = _currentRoundId.current();\n    uint256 batchEntryId = rounds[rid].users.length;\n\n    uint256 totalEntryAmount = 0;\n    EntryHistory[] memory entryHistory = createEntryHistory(); // Array index is contractModeId | used to enforce entry requirements\n\n    BatchEntry storage batchEntry = batchEntryMap[rid][msg.sender]; // Get storage reference for batchEntry by userAddress\n\n    require(\n      batchEntry.totalEntryAmount == 0,\n      \"Already entered in current round\"\n    );\n\n    for (uint256 idx = 0; idx < entryCount; idx++) {\n      require(\n        entries[idx].contractModeId < _currentContractModeId.current(),\n        \"Invalid contract mode\"\n      );\n      ContractMode memory contractMode = contractModes[\n        entries[idx].contractModeId\n      ];\n\n      require(entries[idx].amount != 0, \"Amount cannot be zero\");\n      require(contractMode.isActive, \"Contract mode is not active\");\n      require(\n        entries[idx].pickedNumber < contractMode.cardinality,\n        \"Invalid picked number\"\n      );\n      // Ensure number has already been picked by user\n      require(\n        !entryHistory[contractMode.id].pickedList[entries[idx].pickedNumber],\n        \"Duplicate pickedNumber by contract\"\n      );\n\n      entryHistory[contractMode.id].pickedList[\n        entries[idx].pickedNumber\n      ] = true;\n\n      // Ensure the max entry amount isn't exceeded for the specific contract mode\n      if (contractMode.maxAmount > 0) {\n        // If maxAmount is set(> 0), then keep track of contractMode min/max requirements\n        entryHistory[contractMode.id].gmAmount =\n          entryHistory[contractMode.id].gmAmount +\n          entries[idx].amount;\n        require(\n          entryHistory[contractMode.id].gmAmount < contractMode.maxAmount,\n          \"Contract mode max amount exceeded\"\n        );\n      }\n\n      entryHistory[contractMode.id].entryLimit =\n        entryHistory[contractMode.id].entryLimit +\n        1;\n      require(\n        entryHistory[contractMode.id].entryLimit <= contractMode.entryLimit,\n        \"Contract mode entry limit exceeded\"\n      );\n\n      totalEntryAmount = totalEntryAmount + entries[idx].amount;\n\n      batchEntry.entries.push(\n        Entry({\n          contractModeId: contractMode.id,\n          pickedNumber: entries[idx].pickedNumber,\n          amount: entries[idx].amount\n        })\n      );\n    }\n\n    // If minAmount is set(> 0) for a contractMode, ensure the minAmount for each contractMode was met\n    for (uint256 gmid = 0; gmid < contractModeCount; gmid++) {\n      if (\n        contractModes[gmid].minAmount > 0 &&\n        entryHistory[gmid].gmAmount < contractModes[gmid].minAmount\n      ) {\n        revert(\"Contract mode min amount not met\");\n      }\n    }\n\n    batchEntry.batchEntryId = batchEntryId; // Current index position for user\n    batchEntry.user = msg.sender;\n    batchEntry.totalEntryAmount = totalEntryAmount; // Sum of all entry amounts\n    batchEntry.totalMintAmount = 0; // Probably don't need this since it defaults to 0\n    batchEntry.settled = false; // Probably don't need this since it defaults to false\n\n    rounds[rid].users.push(msg.sender); // Add user's address to round users array\n\n    fareToken.burnFare(msg.sender, totalEntryAmount);\n    fareToken.mintFare(\n      rewardsAddress,\n      (totalEntryAmount * rewardsMint) / 10**18\n    );\n\n    emit EntrySubmitted(rid, batchEntryId, msg.sender);\n  }\n\n  function settleBatchEntry(uint256 roundId, address user)\n    external\n    nonReentrant\n    whenNotPaused\n  {\n    BatchEntry storage batchEntry = batchEntryMap[roundId][user];\n    Entry[] memory entries = batchEntry.entries;\n    require(batchEntry.totalEntryAmount != 0, \"Batch entry does not exist\");\n    require(!batchEntry.settled, \"Entry already settled\");\n    require(_currentRoundId.current() > roundId, \"Round not yet resolved\");\n\n    bool hasMintedNFT = false;\n    uint256 totalMintAmount = 0;\n\n    for (uint256 idx = 0; idx < entries.length; idx++) {\n      if (\n        getIsEliminator(roundId, entries[idx].contractModeId) && !hasMintedNFT\n      ) {\n        mintEliminatorNFT(roundId, batchEntry.user);\n        hasMintedNFT = true;\n      } else {\n        ContractMode memory contractMode = contractModes[\n          entries[idx].contractModeId\n        ];\n\n        uint256 rng = rounds[roundId].randomNum;\n\n        if (rng % contractMode.cardinality == entries[idx].pickedNumber) {\n          totalMintAmount += (entries[idx].amount *\n            contractMode.mintMultiplier);\n        }\n      }\n    }\n\n    if (totalMintAmount > 0) {\n      fareToken.mintFare(batchEntry.user, totalMintAmount);\n      batchEntry.totalMintAmount = totalMintAmount;\n    }\n\n    batchEntry.settled = true;\n\n    emit EntrySettled(roundId, batchEntry.user, batchEntry.totalMintAmount > 0);\n  }\n\n  function concludeRound(bytes32 vrfRequestId, uint256 randomness) internal {\n    require(isRoundPaused, \"Must pause round before concluding.\");\n\n    uint256 rid = _currentRoundId.current();\n    uint256 randomNum = uint256(keccak256(abi.encode(randomness, 1))) % 100;\n    uint256 randomEliminator = uint256(keccak256(abi.encode(randomness, 2))) %\n      CONTRACT_EXPECTED_VALUE_CEILING;\n\n    Round storage round = rounds[rid];\n\n    round.id = rid;\n    round.randomNum = randomNum;\n    round.randomEliminator = randomEliminator;\n    round.vrfRequestId = vrfRequestId;\n    round.vrfNum = randomness;\n\n    // Set Round -> Eliminators[] with current eliminator floors and randomEliminator\n    setEliminators(randomEliminator, rid);\n\n    _currentRoundId.increment();\n    emit RoundConcluded(rid, vrfRequestId, randomNum, randomEliminator);\n\n    // After round completion, allow users to submit entries again\n    isRoundPaused = false;\n    emit RoundPausedChanged(false);\n  }\n\n  function mintEliminatorNFT(uint256 roundId, address user)\n    internal\n    whenNotPaused\n  {\n    emit NFTMint(roundId, user);\n  }\n\n  function requestRandomNumber()\n    public\n    onlyOwner\n    whenNotPaused\n    returns (bytes32 requestId)\n  {\n    require(isRoundPaused, \"Must pause round before concluding.\");\n    require(\n      rounds[_currentRoundId.current()].users.length > 0,\n      \"No users in round.\"\n    );\n    require(LINK.balanceOf(address(this)) >= vrfLinkFee, \"Not enough LINK\");\n\n    requestId = requestRandomness(keyHash, vrfLinkFee);\n    emit RandomNumberRequested(requestId);\n  }\n\n  function fulfillRandomness(bytes32 vrfRequestId, uint256 randomness)\n    internal\n    override\n  {\n    require(\n      rounds[_currentRoundId.current()].users.length > 0,\n      \"No users in round.\"\n    );\n\n    concludeRound(vrfRequestId, randomness);\n  }\n\n  // @NOTE: FOR TESTING ONLY\n  function testConcludeRound(bytes32 vrfRequestId)\n    external\n    onlyOwner\n    whenNotPaused\n  {\n    require(isRoundPaused, \"Must pause round before concluding.\");\n\n    uint256 randomness = getRandomness();\n    uint256 rid = _currentRoundId.current();\n    uint256 randomNum = uint256(keccak256(abi.encode(randomness, 1))) % 100;\n    uint256 randomEliminator = uint256(keccak256(abi.encode(randomness, 2))) %\n      CONTRACT_EXPECTED_VALUE_CEILING;\n\n    Round storage round = rounds[rid];\n\n    round.id = rid;\n    round.randomNum = randomNum;\n    round.randomEliminator = randomEliminator;\n    round.vrfRequestId = vrfRequestId;\n    round.vrfNum = randomness;\n\n    // Set Round -> Eliminators[] with current eliminator floors and randomEliminator\n    setEliminators(randomEliminator, rid);\n\n    _currentRoundId.increment();\n    emit RoundConcluded(rid, vrfRequestId, randomNum, randomEliminator);\n\n    // After round completion, allow users to submit entries again\n    isRoundPaused = false;\n    emit RoundPausedChanged(false);\n  }\n\n  // @NOTE: FOR TESTING ONLY\n  function testFulfillRandomness(bytes32 vrfRequestId, uint256 randomness)\n    external\n    onlyOwner\n    whenNotPaused\n  {\n    // @NOTE: Set isRoundPaused to true here\n    require(\n      rounds[_currentRoundId.current()].users.length > 0,\n      \"No users in round.\"\n    );\n\n    concludeRound(vrfRequestId, randomness);\n  }\n\n  // @NOTE: FOR TESTING ONLY\n  function getRandomness() private view returns (uint256) {\n    uint256 upperLimit = type(uint256).max;\n    uint256 seed = uint256(\n      keccak256(\n        abi.encodePacked(\n          block.timestamp +\n            block.difficulty +\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) /\n              (block.timestamp)) +\n            block.gaslimit +\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\n              (block.timestamp)) +\n            block.number\n        )\n      )\n    );\n\n    return (seed - ((seed / upperLimit) * upperLimit));\n  }\n}\n"
    },
    "contracts/interfaces/IFareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IFareToken is IERC20 {\n  function mintFare(address user, uint256 amount) external;\n\n  function burnFare(address user, uint256 amount) external;\n\n  function setAllowContractMintBurn(\n    address _contractAddress,\n    bool _allow\n  ) external;\n}\n"
    },
    "contracts/libraries/BetHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary BetHelpers {\n    struct Bet {\n        bytes32 requestId;\n        uint side;\n        uint amount;\n        uint stopLoss;\n        uint stopGain;\n        uint64 blockNumber;\n        uint32 count;\n    }\n\n    function calculateCurrentlySpentAmount(\n        Bet memory bet,\n        uint turn\n    ) public pure returns (uint) {\n        return bet.amount * turn;\n    }\n\n    // For the payout we have;\n    //      1e18 precision for multiplier,\n    //      1e18 precision for the payoutMultiplier\n    //          (which is actually the number we will multiply betAmount with)\n    //          (also could be understood as multiplier with houseEdge included)\n    function calculatePayout(\n        Bet memory bet,\n        uint _multiplier,\n        uint _houseEdge\n    ) public pure returns (uint) {\n        return\n            mulDiv(\n                mulDiv(_multiplier, 1 ether - _houseEdge, 1 ether),\n                bet.amount,\n                1 ether\n            );\n    }\n\n    function calculateRewardsPayout(\n        Bet memory bet,\n        uint actualBetCount,\n        uint _rewardsMintPercentage\n    ) public pure returns (uint) {\n        return\n            mulDiv(\n                bet.amount * actualBetCount,\n                _rewardsMintPercentage,\n                1 ether\n            );\n    }\n\n    // Based on if user is in profit or not, check stop gain or check stop loss\n    // Before checking stop loss or checking stop gain make sure that stopGain or stopLoss limit is not 0. If it is zero return false\n    function checkStopLimits(\n        Bet memory bet,\n        uint grossPayout,\n        uint currentlySpentAmount\n    ) public pure returns (bool) {\n        return\n            isInProfit(grossPayout, currentlySpentAmount)\n                ? (\n                    bet.stopGain != 0\n                        ? _uncheckedStopGain(\n                            grossPayout,\n                            currentlySpentAmount,\n                            bet.stopGain\n                        )\n                        : false\n                )\n                : (\n                    bet.stopLoss != 0\n                        ? _uncheckedStopLoss(\n                            grossPayout,\n                            currentlySpentAmount,\n                            bet.stopLoss\n                        )\n                        : false\n                );\n    }\n\n    function isInProfit(\n        uint grossPayout,\n        uint currentlySpentAmount\n    ) public pure returns (bool) {\n        return grossPayout > currentlySpentAmount;\n    }\n\n    // If stopGain is 0, dont even check and return false\n    // If user is not in profit, dont even check and return false\n    function checkStopGain(\n        uint grossPayout,\n        uint currentlySpentAmount,\n        uint stopGainLimit\n    ) public pure returns (bool) {\n        return\n            stopGainLimit > 0 && isInProfit(grossPayout, currentlySpentAmount)\n                ? (\n                    _uncheckedStopGain(\n                        grossPayout,\n                        currentlySpentAmount,\n                        stopGainLimit\n                    )\n                )\n                : false;\n    }\n\n    // If stopLoss is 0, dont even check and return false\n    // If user is in profit, dont even check and return false\n    function checkStopLoss(\n        uint grossPayout,\n        uint currentlySpentAmount,\n        uint stopLossLimit\n    ) public pure returns (bool) {\n        return\n            stopLossLimit > 0 && !isInProfit(grossPayout, currentlySpentAmount)\n                ? _uncheckedStopLoss(\n                    grossPayout,\n                    currentlySpentAmount,\n                    stopLossLimit\n                )\n                : false;\n    }\n\n    // Because of the usage of \"uint\" rather than \"int\"s should only be called when we know (grossPayout > currentlySpentAmount)\n    // Which means, it only should be called after isInProfit returns true\n    // Because user might not have a stopLimit and in that it would be represented as 0. If it's limit is 0 it should not be checked\n    // Which means it only should be called after stopGainLimit is not 0\n    function _uncheckedStopGain(\n        uint grossPayout,\n        uint currentlySpentAmount,\n        uint stopGainLimit\n    ) public pure returns (bool) {\n        return grossPayout - currentlySpentAmount >= stopGainLimit;\n    }\n\n    // Because of the usage of \"uint\"s rather than \"int\"s should only be called when we know (currentlySpentAmount > grossPayout)\n    // Which means, it only should be called after isInProfit returns false\n    // Because user might not have a stopLimit and in that it would be represented as 0. If it's limit is 0 it should not be checked\n    // Which means it only should be called after stopLossLimit is not 0\n    function _uncheckedStopLoss(\n        uint grossPayout,\n        uint currentlySpentAmount,\n        uint stopLossLimit\n    ) public pure returns (bool) {\n        return currentlySpentAmount - grossPayout >= stopLossLimit;\n    }\n\n    // NOTE: From OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol)\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n}\n"
    },
    "contracts/requesters/BaseRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nabstract contract BaseRequester {\n    // TODO: Maybe this should be internal, I am using it as public so that I would test it.\n    // TODO: Could use uint as key to the mapping. Technically both bytes32 and uint256 would work.\n    // In my opinion, bytes32 would be better because there could be a lot of different requester types and they would implement their own method.\n    // So, having bytes32 as the generic version would make more sense.\n    // But, considering chainlink VRF would be used most frequently. Maybe it should be just like how VRF does it. Others would adapt to it\n    mapping(bytes32 => bool) public expectingRequestWithIdToBeFulfilled;\n\n    // As the contract that is implementing a specific requester. You will override this function to implement your own way of requesting.\n    // As the contract that uses any requester. All you have to do is call this function.\n    function requestRandomNumbers(\n        uint256 amount\n    ) internal virtual returns (bytes32);\n\n    // As the contract that is implementing a specific requester. When you are resolving the random numbers, you will call this function at the end.\n    // As the contract that uses any requester. You override this function to implement your own way of handling random numbers. (Generally it will be resolving the bet)\n    function resolveRandomNumbers(\n        bytes32 requestId,\n        uint256[] memory randomNumbers\n    ) internal virtual;\n}\n"
    },
    "contracts/requesters/QRNGRequester.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BaseRequester.sol\";\n\n/**\n * Abstract contract that allows inheriting contract to easily make QRNG request using API3\n */\nabstract contract QRNGRequester is BaseRequester, RrpRequesterV0, Ownable {\n    // Airnode related values\n    address public airnode;\n    bytes32 public endpointIdUint256;\n    bytes32 public endpointIdUint256Array;\n    address public sponsorWallet;\n\n    constructor(address _airnodeRrp) RrpRequesterV0(_airnodeRrp) {}\n\n    function setRequestParameters(\n        address _airnode,\n        bytes32 _endpointIdUint256Array,\n        address _sponsorWallet\n    ) external onlyOwner {\n        airnode = _airnode;\n        endpointIdUint256Array = _endpointIdUint256Array;\n        // Be aware of the difference between sponsor wallet and sponsor address.\n        // When you want to learn Sponsor Wallet you have to run this: https://docs.api3.org/airnode/v0.9/reference/packages/admin-cli.html#derive-sponsor-wallet-address\n        // Where sponsor address is the address of this smart contract and output would be sponsor wallet\n        sponsorWallet = _sponsorWallet;\n    }\n\n    function requestRandomNumbers(\n        uint256 amount\n    ) internal override returns (bytes32) {\n        return requestQRNG(amount);\n    }\n\n    // TODO: Right now, when someone requires a random number they do not pay anything extra as in native token or in link\n    // TODO: I guess we have to require some kind of payment. For QRNG by API3, the sponsor wallet would pay the gas fee for the callback transaction\n    // TODO: Therefore, we could require \"requestRNG\" to be payable and directly send those funds to sponsor wallet.\n    // TODO: I am not sure how to estimate this value to be honest. For Chainlink's VRF I used price feeds of native token and link and used average LINK cost for the callback.\n    // Allows user to request \"betCount\" amount of random numbers.\n    // \"fulfillFunctionId\" is the selector of the callback function user wants to callback.\n    // It will be called by (bytes32 requestId, uint[] memory randomNumberArray) parameters.\n    // So a contract that uses QRNGRequester, should implement a function with mentioned parameters as the callback function.\n    function requestQRNG(uint betCount) private returns (bytes32 requestId) {\n        requestId = airnodeRrp.makeFullRequest(\n            airnode,\n            endpointIdUint256Array,\n            address(this),\n            sponsorWallet,\n            address(this),\n            this.resolveQRNG.selector,\n            // Using Airnode ABI to encode the parameters\n            abi.encode(bytes32(\"1u\"), bytes32(\"size\"), betCount)\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    // This is the original callback function that will be called by sponsor wallet.\n    // It will call back the `resolveRandomNumbers` defined by the `BaseRequester`\n    function resolveQRNG(\n        bytes32 requestId,\n        bytes calldata data\n    ) external onlyAirnodeRrp {\n        require(\n            expectingRequestWithIdToBeFulfilled[requestId],\n            \"requestId not known\"\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = false;\n        uint256[] memory qrngUint256Array = abi.decode(data, (uint256[]));\n        resolveRandomNumbers(requestId, qrngUint256Array);\n    }\n}\n"
    },
    "contracts/requesters/VRFRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\n// import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BaseRequester.sol\";\n\n/**\n * Abstract contract that allows inheriting contract to easily make VRF requests using Chainlink\n */\nabstract contract VRFRequester is BaseRequester, VRFConsumerBaseV2, Ownable {\n    // Native token / USD price feed\n    // AggregatorV3Interface internal NUpriceFeed;\n    // LINK / USD price feed\n    // AggregatorV3Interface internal LUpriceFeed;\n    // VRF Coordinator\n    VRFCoordinatorV2Interface internal COORDINATOR;\n\n    // VRF related values for Mumbai\n    // uint64 public subscriptionId;\n    // // TODO: Make sure that callback functions do not run out of gas\n    // bytes32 public keyHash =\n    //     0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f;\n    // uint32 public callbackGasLimit = 2500000;\n    // uint16 public requestConfirmations = 3;\n    // This was the average LINK amount we had to pay for VRF requests on Polygon Mumbai Testnet\n    // uint public vrfFeeInLink = 0.00053 ether;\n\n    // VRF related values for Fuji\n    uint64 public subscriptionId;\n    // TODO: Make sure that callback functions do not run out of gas\n    bytes32 public keyHash =\n        0x354d2f95da55398f44b7cff77da56283d9c6c829a4bdf1bbcaf2ad6a4d081f61;\n    uint32 public callbackGasLimit = 2500000;\n    uint16 public requestConfirmations = 1;\n\n    /**\n     * Network: Mumbai\n     * Aggregator: MATIC/USD\n     * Address: 0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada\n     *\n     * Network: Mumbai\n     * Aggregator: LINK/USD\n     * Address: 0x1C2252aeeD50e0c9B64bDfF2735Ee3C932F5C408\n     *\n     * Mumbai network\n     * address vrfCoordinator = 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed;\n     *\n     */\n    constructor(\n        uint64 _subscriptionId,\n        // // address _nativeTokenAggregatorAddress,\n        // address _linkTokenAggregatorAddress,\n        address _vrfCoordinator\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\n        require(\n            _vrfCoordinator != address(0),\n            \"Not a valid address for _vrfCoordinator\"\n        );\n        // NUpriceFeed = AggregatorV3Interface(_nativeTokenAggregatorAddress);\n        // LUpriceFeed = AggregatorV3Interface(_linkTokenAggregatorAddress);\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n        subscriptionId = _subscriptionId;\n    }\n\n    function getVRFCoordinatorAddress()\n        public\n        view\n        returns (address vrfAddress)\n    {\n        vrfAddress = address(COORDINATOR);\n    }\n\n    function setRequestParameters(\n        uint64 _subscriptionId,\n        // address _nativeTokenAggregatorAddress,\n        // address _linkTokenAggregatorAddress,\n        address _vrfCoordinator,\n        uint16 _requestConfirmations,\n        uint32 _callbackGasLimit,\n        bytes32 _keyHash\n    ) external onlyOwner {\n        // NUpriceFeed = AggregatorV3Interface(_nativeTokenAggregatorAddress);\n        // LUpriceFeed = AggregatorV3Interface(_linkTokenAggregatorAddress);\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n        subscriptionId = _subscriptionId;\n        requestConfirmations = _requestConfirmations;\n        callbackGasLimit = _callbackGasLimit;\n        keyHash = _keyHash;\n    }\n\n    // function setVrfFeeInLink(uint newFee) public onlyOwner {\n    //     vrfFeeInLink = newFee;\n    // }\n\n    // function vrfFeeInUsd() public view returns (uint) {\n    //     return vrfFeeInLink * uint(getLinksLatestPriceInUsd());\n    // }\n\n    // function vrfFeeInNativeToken() public view returns (uint) {\n    //     return vrfFeeInUsd() / uint(getNativeTokenLatestPriceInUsd());\n    // }\n\n    // /**\n    //  * Returns latest price for NATIVE TOKEN\n    //  */\n    // function getNativeTokenLatestPriceInUsd() public view returns (int price) {\n    //     (\n    //         ,\n    //         /*uint80 roundID*/ price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\n    //         ,\n    //         ,\n\n    //     ) = NUpriceFeed.latestRoundData();\n    // }\n\n    // /**\n    //  * Returns latest price for LINK\n    //  */\n    // function getLinksLatestPriceInUsd() public view returns (int price) {\n    //     (\n    //         ,\n    //         /*uint80 roundID*/ price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\n    //         ,\n    //         ,\n\n    //     ) = LUpriceFeed.latestRoundData();\n    // }\n\n    function requestRandomNumbers(\n        uint256 amount\n    ) internal override returns (bytes32) {\n        return bytes32(requestVRF(uint32(amount)));\n    }\n\n    // TODO: Requires user to pay in native token for the average LINK fee.\n    // TODO: One problem is \"vrfFeeInNativeToken()\" value might differ in between user running it vs it is ran by blockchain.\n    // TODO: So it might fail some times. What to do in this case?\n    // TODO: What comes to my mind is storing fee amount and calculated roundID and use the stored one as long as certain amount of rounds past.\n    function requestVRF(uint32 betCount) private returns (uint256 requestId) {\n        // Make sure that user has paid for VRF fee in matic token when requesting coinFlip\n        // TODO: Uncomment this, after tests end for VRF vs QRNG\n        // require(\n        //     msg.value >= vrfFeeInNativeToken(), // TODO: Caller technique, +- percentage and repay the remaining one\n        //     \"Insufficient payment for vrf\"\n        // );\n        // TODO: In ZKasino inside this function they repay the extra amount paid but I do not know how\n        // TODO: Could extend this to swap the token directly to LINK and send that LINK to funder address of the Chainlink VRF subscription funder. But user would have to pay the gas for all of this\n        // TODO: After thinking about the above line related to swaping. I guess we could also check the price from a DEX rather than Chainlink Price Feeds\n\n        // Request random number\n        requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            betCount\n        );\n        expectingRequestWithIdToBeFulfilled[bytes32(requestId)] = true;\n    }\n\n    // This is the original callback function that will be called by Chainlink.\n    // It will call back the `resolveRandomNumbers` defined by the `BaseRequester`\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        require(\n            expectingRequestWithIdToBeFulfilled[bytes32(requestId)],\n            \"requestId not known\"\n        );\n        expectingRequestWithIdToBeFulfilled[bytes32(requestId)] = false;\n        resolveRandomNumbers(bytes32(requestId), randomWords);\n    }\n}\n"
    },
    "contracts/test/FareCoinFlipQRNG.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../baseGames/singleplayer/BaseSPGame.sol\";\nimport \"../requesters/QRNGRequester.sol\";\n\ncontract FareCoinFlipQRNG is BaseSPGame, QRNGRequester {\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    address _airnodeRrp\n  ) BaseSPGame(_fareTokenAddress, _rewardsAddress) QRNGRequester(_airnodeRrp) {}\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 2;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    return betSide == houseSide ? 1 : 0;\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    return outcome == 1 ? multiplier * 2 : 0;\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(side < 2, \"Side can only be 0 or 1\");\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n}\n"
    },
    "contracts/test/FareCoinFlipVRF.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../baseGames/singleplayer/BaseSPGame.sol\";\nimport \"../requesters/VRFRequester.sol\";\n\ncontract FareCoinFlipVRF is BaseSPGame, VRFRequester {\n  /**\n   * Network: Mumbai\n   * Aggregator: MATIC/USD\n   * Address: 0xd0D5e3DB44DE05E9F294BB0a3bEEaF030DE24Ada\n   *\n   * Network: Mumbai\n   * Aggregator: LINK/USD\n   * Address: 0x1C2252aeeD50e0c9B64bDfF2735Ee3C932F5C408\n   */\n  constructor(\n    address _fareTokenAddress,\n    address _rewardsAddress,\n    uint64 _subscriptionId,\n    // address _nativeTokenAggregatorAddress,\n    // address _linkTokenAggregatorAddress,\n    address _vrfCoordinator\n  )\n    BaseSPGame(_fareTokenAddress, _rewardsAddress)\n    VRFRequester(\n      _subscriptionId,\n      // _nativeTokenAggregatorAddress,\n      // _linkTokenAggregatorAddress,\n      _vrfCoordinator\n    )\n  {}\n\n  function gameSpecificGetHouseSide(\n    uint randomNumber,\n    uint betSide\n  ) public view override returns (uint) {\n    return randomNumber % 2;\n  }\n\n  function gameSpecificGetOutcome(\n    uint houseSide,\n    uint betSide\n  ) public view override returns (uint) {\n    return betSide == houseSide ? 1 : 0;\n  }\n\n  function gameSpecificGetMultiplier(\n    uint outcome,\n    uint betSide\n  ) public view override returns (uint) {\n    return outcome == 1 ? multiplier * 2 : 0;\n  }\n\n  function placeBet(\n    uint side,\n    uint amount,\n    uint stopLoss,\n    uint stopGain,\n    uint32 count\n  ) public payable override {\n    require(side < 2, \"Side can only be 0 or 1\");\n    _placeBet(side, amount, stopLoss, stopGain, count);\n  }\n\n  function resolveRandomNumbers(\n    bytes32 requestId,\n    uint256[] memory randomNumbers\n  ) internal override {\n    _resolveBet(requestId, randomNumbers);\n  }\n\n  function refundBet() public override {\n    _refundBet();\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}